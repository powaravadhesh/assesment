"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-number-format";
exports.ids = ["vendor-chunks/react-number-format"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-number-format/dist/react-number-format.es.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberFormatBase: () => (/* binding */ NumberFormatBase),\n/* harmony export */   NumericFormat: () => (/* binding */ NumericFormat),\n/* harmony export */   PatternFormat: () => (/* binding */ PatternFormat),\n/* harmony export */   getNumericCaretBoundary: () => (/* binding */ getCaretBoundary),\n/* harmony export */   getPatternCaretBoundary: () => (/* binding */ getCaretBoundary$1),\n/* harmony export */   numericFormatter: () => (/* binding */ format),\n/* harmony export */   patternFormatter: () => (/* binding */ format$1),\n/* harmony export */   removeNumericFormat: () => (/* binding */ removeFormatting),\n/* harmony export */   removePatternFormat: () => (/* binding */ removeFormatting$1),\n/* harmony export */   useNumericFormat: () => (/* binding */ useNumericFormat),\n/* harmony export */   usePatternFormat: () => (/* binding */ usePatternFormat)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * react-number-format - 5.3.3\n * Author : Sudhanshu Yadav\n * Copyright (c) 2016, 2024 to Sudhanshu Yadav, released under the MIT license.\n * https://github.com/s-yadav/react-number-format\n */ \n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s){\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {\n            t[p] = s[p];\n        }\n    }\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {\n                t[p[i]] = s[p[i]];\n            }\n        }\n    }\n    return t;\n}\nvar SourceType;\n(function(SourceType) {\n    SourceType[\"event\"] = \"event\";\n    SourceType[\"props\"] = \"prop\";\n})(SourceType || (SourceType = {}));\n// basic noop function\nfunction noop() {}\nfunction memoizeOnce(cb) {\n    var lastArgs;\n    var lastValue = undefined;\n    return function() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        if (lastArgs && args.length === lastArgs.length && args.every(function(value, index) {\n            return value === lastArgs[index];\n        })) {\n            return lastValue;\n        }\n        lastArgs = args;\n        lastValue = cb.apply(void 0, args);\n        return lastValue;\n    };\n}\nfunction charIsNumber(char) {\n    return !!(char || \"\").match(/\\d/);\n}\nfunction isNil(val) {\n    return val === null || val === undefined;\n}\nfunction isNanValue(val) {\n    return typeof val === \"number\" && isNaN(val);\n}\nfunction isNotValidValue(val) {\n    return isNil(val) || isNanValue(val) || typeof val === \"number\" && !isFinite(val);\n}\nfunction escapeRegExp(str) {\n    return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n}\nfunction getThousandsGroupRegex(thousandsGroupStyle) {\n    switch(thousandsGroupStyle){\n        case \"lakh\":\n            return /(\\d+?)(?=(\\d\\d)+(\\d)(?!\\d))(\\.\\d+)?/g;\n        case \"wan\":\n            return /(\\d)(?=(\\d{4})+(?!\\d))/g;\n        case \"thousand\":\n        default:\n            return /(\\d)(?=(\\d{3})+(?!\\d))/g;\n    }\n}\nfunction applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {\n    var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);\n    var index = str.search(/[1-9]/);\n    index = index === -1 ? str.length : index;\n    return str.substring(0, index) + str.substring(index, str.length).replace(thousandsGroupRegex, \"$1\" + thousandSeparator);\n}\nfunction usePersistentCallback(cb) {\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(cb);\n    // keep the callback ref upto date\n    callbackRef.current = cb;\n    /**\n     * initialize a persistent callback which never changes\n     * through out the component lifecycle\n     */ var persistentCbRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        return callbackRef.current.apply(callbackRef, args);\n    });\n    return persistentCbRef.current;\n}\n//spilt a float number into different parts beforeDecimal, afterDecimal, and negation\nfunction splitDecimal(numStr, allowNegative) {\n    if (allowNegative === void 0) allowNegative = true;\n    var hasNegation = numStr[0] === \"-\";\n    var addNegation = hasNegation && allowNegative;\n    numStr = numStr.replace(\"-\", \"\");\n    var parts = numStr.split(\".\");\n    var beforeDecimal = parts[0];\n    var afterDecimal = parts[1] || \"\";\n    return {\n        beforeDecimal: beforeDecimal,\n        afterDecimal: afterDecimal,\n        hasNegation: hasNegation,\n        addNegation: addNegation\n    };\n}\nfunction fixLeadingZero(numStr) {\n    if (!numStr) {\n        return numStr;\n    }\n    var isNegative = numStr[0] === \"-\";\n    if (isNegative) {\n        numStr = numStr.substring(1, numStr.length);\n    }\n    var parts = numStr.split(\".\");\n    var beforeDecimal = parts[0].replace(/^0+/, \"\") || \"0\";\n    var afterDecimal = parts[1] || \"\";\n    return \"\" + (isNegative ? \"-\" : \"\") + beforeDecimal + (afterDecimal ? \".\" + afterDecimal : \"\");\n}\n/**\n * limit decimal numbers to given scale\n * Not used .fixedTo because that will break with big numbers\n */ function limitToScale(numStr, scale, fixedDecimalScale) {\n    var str = \"\";\n    var filler = fixedDecimalScale ? \"0\" : \"\";\n    for(var i = 0; i <= scale - 1; i++){\n        str += numStr[i] || filler;\n    }\n    return str;\n}\nfunction repeat(str, count) {\n    return Array(count + 1).join(str);\n}\nfunction toNumericString(num) {\n    var _num = num + \"\"; // typecast number to string\n    // store the sign and remove it from the number.\n    var sign = _num[0] === \"-\" ? \"-\" : \"\";\n    if (sign) {\n        _num = _num.substring(1);\n    }\n    // split the number into cofficient and exponent\n    var ref = _num.split(/[eE]/g);\n    var coefficient = ref[0];\n    var exponent = ref[1];\n    // covert exponent to number;\n    exponent = Number(exponent);\n    // if there is no exponent part or its 0, return the coffiecient with sign\n    if (!exponent) {\n        return sign + coefficient;\n    }\n    coefficient = coefficient.replace(\".\", \"\");\n    /**\n     * for scientific notation the current decimal index will be after first number (index 0)\n     * So effective decimal index will always be 1 + exponent value\n     */ var decimalIndex = 1 + exponent;\n    var coffiecientLn = coefficient.length;\n    if (decimalIndex < 0) {\n        // if decimal index is less then 0 add preceding 0s\n        // add 1 as join will have\n        coefficient = \"0.\" + repeat(\"0\", Math.abs(decimalIndex)) + coefficient;\n    } else if (decimalIndex >= coffiecientLn) {\n        // if decimal index is less then 0 add leading 0s\n        coefficient = coefficient + repeat(\"0\", decimalIndex - coffiecientLn);\n    } else {\n        // else add decimal point at proper index\n        coefficient = (coefficient.substring(0, decimalIndex) || \"0\") + \".\" + coefficient.substring(decimalIndex);\n    }\n    return sign + coefficient;\n}\n/**\n * This method is required to round prop value to given scale.\n * Not used .round or .fixedTo because that will break with big numbers\n */ function roundToPrecision(numStr, scale, fixedDecimalScale) {\n    //if number is empty don't do anything return empty string\n    if ([\n        \"\",\n        \"-\"\n    ].indexOf(numStr) !== -1) {\n        return numStr;\n    }\n    var shouldHaveDecimalSeparator = (numStr.indexOf(\".\") !== -1 || fixedDecimalScale) && scale;\n    var ref = splitDecimal(numStr);\n    var beforeDecimal = ref.beforeDecimal;\n    var afterDecimal = ref.afterDecimal;\n    var hasNegation = ref.hasNegation;\n    var floatValue = parseFloat(\"0.\" + (afterDecimal || \"0\"));\n    var floatValueStr = afterDecimal.length <= scale ? \"0.\" + afterDecimal : floatValue.toFixed(scale);\n    var roundedDecimalParts = floatValueStr.split(\".\");\n    var intPart = beforeDecimal;\n    // if we have cary over from rounding decimal part, add that on before decimal\n    if (beforeDecimal && Number(roundedDecimalParts[0])) {\n        intPart = beforeDecimal.split(\"\").reverse().reduce(function(roundedStr, current, idx) {\n            if (roundedStr.length > idx) {\n                return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);\n            }\n            return current + roundedStr;\n        }, roundedDecimalParts[0]);\n    }\n    var decimalPart = limitToScale(roundedDecimalParts[1] || \"\", scale, fixedDecimalScale);\n    var negation = hasNegation ? \"-\" : \"\";\n    var decimalSeparator = shouldHaveDecimalSeparator ? \".\" : \"\";\n    return \"\" + negation + intPart + decimalSeparator + decimalPart;\n}\n/** set the caret positon in an input field **/ function setCaretPosition(el, caretPos) {\n    el.value = el.value;\n    // ^ this is used to not only get 'focus', but\n    // to make sure we don't have it everything -selected-\n    // (it causes an issue in chrome, and having it doesn't hurt any other browser)\n    if (el !== null) {\n        /* @ts-ignore */ if (el.createTextRange) {\n            /* @ts-ignore */ var range = el.createTextRange();\n            range.move(\"character\", caretPos);\n            range.select();\n            return true;\n        }\n        // (el.selectionStart === 0 added for Firefox bug)\n        if (el.selectionStart || el.selectionStart === 0) {\n            el.focus();\n            el.setSelectionRange(caretPos, caretPos);\n            return true;\n        }\n        // fail city, fortunately this never happens (as far as I've tested) :)\n        el.focus();\n        return false;\n    }\n}\nvar findChangeRange = memoizeOnce(function(prevValue, newValue) {\n    var i = 0, j = 0;\n    var prevLength = prevValue.length;\n    var newLength = newValue.length;\n    while(prevValue[i] === newValue[i] && i < prevLength){\n        i++;\n    }\n    //check what has been changed from last\n    while(prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i){\n        j++;\n    }\n    return {\n        from: {\n            start: i,\n            end: prevLength - j\n        },\n        to: {\n            start: i,\n            end: newLength - j\n        }\n    };\n});\n/*\n  Returns a number whose value is limited to the given range\n*/ function clamp(num, min, max) {\n    return Math.min(Math.max(num, min), max);\n}\nfunction geInputCaretPosition(el) {\n    /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/ return Math.max(el.selectionStart, el.selectionEnd);\n}\nfunction addInputMode() {\n    return typeof navigator !== \"undefined\" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));\n}\nfunction getDefaultChangeMeta(value) {\n    return {\n        from: {\n            start: 0,\n            end: 0\n        },\n        to: {\n            start: 0,\n            end: value.length\n        },\n        lastValue: \"\"\n    };\n}\nfunction getMaskAtIndex(mask, index) {\n    if (mask === void 0) mask = \" \";\n    if (typeof mask === \"string\") {\n        return mask;\n    }\n    return mask[index] || \" \";\n}\nfunction defaultIsCharacterSame(ref) {\n    var currentValue = ref.currentValue;\n    var formattedValue = ref.formattedValue;\n    var currentValueIndex = ref.currentValueIndex;\n    var formattedValueIndex = ref.formattedValueIndex;\n    return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];\n}\nfunction getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, /**\n * format function can change the character, the caret engine relies on mapping old value and new value\n * In such case if character is changed, parent can tell which chars are equivalent\n * Some example, all allowedDecimalCharacters are updated to decimalCharacters, 2nd case if user is coverting\n * number to different numeric system.\n */ isCharacterSame) {\n    if (isCharacterSame === void 0) isCharacterSame = defaultIsCharacterSame;\n    /**\n     * if something got inserted on empty value, add the formatted character before the current value,\n     * This is to avoid the case where typed character is present on format characters\n     */ var firstAllowedPosition = boundary.findIndex(function(b) {\n        return b;\n    });\n    var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);\n    if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {\n        lastFormattedValue = prefixFormat;\n        curValue = prefixFormat + curValue;\n        curCaretPos = curCaretPos + prefixFormat.length;\n    }\n    var curValLn = curValue.length;\n    var formattedValueLn = newFormattedValue.length;\n    // create index map\n    var addedIndexMap = {};\n    var indexMap = new Array(curValLn);\n    for(var i = 0; i < curValLn; i++){\n        indexMap[i] = -1;\n        for(var j = 0, jLn = formattedValueLn; j < jLn; j++){\n            var isCharSame = isCharacterSame({\n                currentValue: curValue,\n                lastValue: lastFormattedValue,\n                formattedValue: newFormattedValue,\n                currentValueIndex: i,\n                formattedValueIndex: j\n            });\n            if (isCharSame && addedIndexMap[j] !== true) {\n                indexMap[i] = j;\n                addedIndexMap[j] = true;\n                break;\n            }\n        }\n    }\n    /**\n     * For current caret position find closest characters (left and right side)\n     * which are properly mapped to formatted value.\n     * The idea is that the new caret position will exist always in the boundary of\n     * that mapped index\n     */ var pos = curCaretPos;\n    while(pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))){\n        pos++;\n    }\n    // if the caret position is on last keep the endIndex as last for formatted value\n    var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];\n    pos = curCaretPos - 1;\n    while(pos > 0 && indexMap[pos] === -1){\n        pos--;\n    }\n    var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;\n    /**\n     * case where a char is added on suffix and removed from middle, example 2sq345 becoming $2,345 sq\n     * there is still a mapping but the order of start index and end index is changed\n     */ if (startIndex > endIndex) {\n        return endIndex;\n    }\n    /**\n     * given the current caret position if it closer to startIndex\n     * keep the new caret position on start index or keep it closer to endIndex\n     */ return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;\n}\n/* This keeps the caret within typing area so people can't type in between prefix or suffix or format characters */ function getCaretPosInBoundary(value, caretPos, boundary, direction) {\n    var valLn = value.length;\n    // clamp caret position to [0, value.length]\n    caretPos = clamp(caretPos, 0, valLn);\n    if (direction === \"left\") {\n        while(caretPos >= 0 && !boundary[caretPos]){\n            caretPos--;\n        }\n        // if we don't find any suitable caret position on left, set it on first allowed position\n        if (caretPos === -1) {\n            caretPos = boundary.indexOf(true);\n        }\n    } else {\n        while(caretPos <= valLn && !boundary[caretPos]){\n            caretPos++;\n        }\n        // if we don't find any suitable caret position on right, set it on last allowed position\n        if (caretPos > valLn) {\n            caretPos = boundary.lastIndexOf(true);\n        }\n    }\n    // if we still don't find caret position, set it at the end of value\n    if (caretPos === -1) {\n        caretPos = valLn;\n    }\n    return caretPos;\n}\nfunction caretUnknownFormatBoundary(formattedValue) {\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    for(var i = 0, ln = boundaryAry.length; i < ln; i++){\n        // consider caret to be in boundary if it is before or after numeric value\n        boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));\n    }\n    return boundaryAry;\n}\nfunction useInternalValues(value, defaultValue, valueIsNumericString, format, removeFormatting, onValueChange) {\n    if (onValueChange === void 0) onValueChange = noop;\n    var getValues = usePersistentCallback(function(value, valueIsNumericString) {\n        var formattedValue, numAsString;\n        if (isNotValidValue(value)) {\n            numAsString = \"\";\n            formattedValue = \"\";\n        } else if (typeof value === \"number\" || valueIsNumericString) {\n            numAsString = typeof value === \"number\" ? toNumericString(value) : value;\n            formattedValue = format(numAsString);\n        } else {\n            numAsString = removeFormatting(value, undefined);\n            formattedValue = format(numAsString);\n        }\n        return {\n            formattedValue: formattedValue,\n            numAsString: numAsString\n        };\n    });\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);\n    });\n    var values = ref[0];\n    var setValues = ref[1];\n    var _onValueChange = function(newValues, sourceInfo) {\n        if (newValues.formattedValue !== values.formattedValue) {\n            setValues({\n                formattedValue: newValues.formattedValue,\n                numAsString: newValues.value\n            });\n        }\n        // call parent on value change if only if formatted value is changed\n        onValueChange(newValues, sourceInfo);\n    };\n    // if value is switch from controlled to uncontrolled, use the internal state's value to format with new props\n    var _value = value;\n    var _valueIsNumericString = valueIsNumericString;\n    if (isNil(value)) {\n        _value = values.numAsString;\n        _valueIsNumericString = true;\n    }\n    var newValues = getValues(_value, _valueIsNumericString);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        setValues(newValues);\n    }, [\n        newValues.formattedValue\n    ]);\n    return [\n        values,\n        _onValueChange\n    ];\n}\nfunction defaultRemoveFormatting(value) {\n    return value.replace(/[^0-9]/g, \"\");\n}\nfunction defaultFormat(value) {\n    return value;\n}\nfunction NumberFormatBase(props) {\n    var type = props.type;\n    if (type === void 0) type = \"text\";\n    var displayType = props.displayType;\n    if (displayType === void 0) displayType = \"input\";\n    var customInput = props.customInput;\n    var renderText = props.renderText;\n    var getInputRef = props.getInputRef;\n    var format = props.format;\n    if (format === void 0) format = defaultFormat;\n    var removeFormatting = props.removeFormatting;\n    if (removeFormatting === void 0) removeFormatting = defaultRemoveFormatting;\n    var defaultValue = props.defaultValue;\n    var valueIsNumericString = props.valueIsNumericString;\n    var onValueChange = props.onValueChange;\n    var isAllowed = props.isAllowed;\n    var onChange = props.onChange;\n    if (onChange === void 0) onChange = noop;\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var onMouseUp = props.onMouseUp;\n    if (onMouseUp === void 0) onMouseUp = noop;\n    var onFocus = props.onFocus;\n    if (onFocus === void 0) onFocus = noop;\n    var onBlur = props.onBlur;\n    if (onBlur === void 0) onBlur = noop;\n    var propValue = props.value;\n    var getCaretBoundary = props.getCaretBoundary;\n    if (getCaretBoundary === void 0) getCaretBoundary = caretUnknownFormatBoundary;\n    var isValidInputCharacter = props.isValidInputCharacter;\n    if (isValidInputCharacter === void 0) isValidInputCharacter = charIsNumber;\n    var isCharacterSame = props.isCharacterSame;\n    var otherProps = __rest(props, [\n        \"type\",\n        \"displayType\",\n        \"customInput\",\n        \"renderText\",\n        \"getInputRef\",\n        \"format\",\n        \"removeFormatting\",\n        \"defaultValue\",\n        \"valueIsNumericString\",\n        \"onValueChange\",\n        \"isAllowed\",\n        \"onChange\",\n        \"onKeyDown\",\n        \"onMouseUp\",\n        \"onFocus\",\n        \"onBlur\",\n        \"value\",\n        \"getCaretBoundary\",\n        \"isValidInputCharacter\",\n        \"isCharacterSame\"\n    ]);\n    var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format, removeFormatting, onValueChange);\n    var ref_0 = ref[0];\n    var formattedValue = ref_0.formattedValue;\n    var numAsString = ref_0.numAsString;\n    var onFormattedValueChange = ref[1];\n    var lastUpdatedValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        formattedValue: formattedValue,\n        numAsString: numAsString\n    });\n    var _onValueChange = function(values, source) {\n        lastUpdatedValue.current = {\n            formattedValue: values.formattedValue,\n            numAsString: values.value\n        };\n        onFormattedValueChange(values, source);\n    };\n    var ref$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    var mounted = ref$1[0];\n    var setMounted = ref$1[1];\n    var focusedElm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        setCaretTimeout: null,\n        focusTimeout: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        setMounted(true);\n        return function() {\n            clearTimeout(timeout.current.setCaretTimeout);\n            clearTimeout(timeout.current.focusTimeout);\n        };\n    }, []);\n    var _format = format;\n    var getValueObject = function(formattedValue, numAsString) {\n        var floatValue = parseFloat(numAsString);\n        return {\n            formattedValue: formattedValue,\n            value: numAsString,\n            floatValue: isNaN(floatValue) ? undefined : floatValue\n        };\n    };\n    var setPatchedCaretPosition = function(el, caretPos, currentValue) {\n        // don't reset the caret position when the whole input content is selected\n        if (el.selectionStart === 0 && el.selectionEnd === el.value.length) {\n            return;\n        }\n        /* setting caret position within timeout of 0ms is required for mobile chrome,\n        otherwise browser resets the caret position after we set it\n        We are also setting it without timeout so that in normal browser we don't see the flickering */ setCaretPosition(el, caretPos);\n        timeout.current.setCaretTimeout = setTimeout(function() {\n            if (el.value === currentValue && el.selectionStart !== caretPos) {\n                setCaretPosition(el, caretPos);\n            }\n        }, 0);\n    };\n    /* This keeps the caret within typing area so people can't type in between prefix or suffix */ var correctCaretPosition = function(value, caretPos, direction) {\n        return getCaretPosInBoundary(value, caretPos, getCaretBoundary(value), direction);\n    };\n    var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {\n        var caretBoundary = getCaretBoundary(newFormattedValue);\n        var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);\n        //correct caret position if its outside of editable area\n        updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);\n        return updatedCaretPos;\n    };\n    var updateValueAndCaretPosition = function(params) {\n        var newFormattedValue = params.formattedValue;\n        if (newFormattedValue === void 0) newFormattedValue = \"\";\n        var input = params.input;\n        var source = params.source;\n        var event = params.event;\n        var numAsString = params.numAsString;\n        var caretPos;\n        if (input) {\n            var inputValue = params.inputValue || input.value;\n            var currentCaretPosition = geInputCaretPosition(input);\n            /**\n             * set the value imperatively, this is required for IE fix\n             * This is also required as if new caret position is beyond the previous value.\n             * Caret position will not be set correctly\n             */ input.value = newFormattedValue;\n            //get the caret position\n            caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition);\n            //set caret position imperatively\n            if (caretPos !== undefined) {\n                setPatchedCaretPosition(input, caretPos, newFormattedValue);\n            }\n        }\n        if (newFormattedValue !== formattedValue) {\n            // trigger onValueChange synchronously, so parent is updated along with the number format. Fix for #277, #287\n            _onValueChange(getValueObject(newFormattedValue, numAsString), {\n                event: event,\n                source: source\n            });\n        }\n    };\n    /**\n     * if the formatted value is not synced to parent, or if the formatted value is different from last synced value sync it\n     * we also don't need to sync to the parent if no formatting is applied\n     * if the formatting props is removed, in which case last formatted value will be different from the numeric string value\n     * in such case we need to inform the parent.\n     */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        var ref = lastUpdatedValue.current;\n        var lastFormattedValue = ref.formattedValue;\n        var lastNumAsString = ref.numAsString;\n        if (formattedValue !== lastFormattedValue && (formattedValue !== numAsString || lastFormattedValue !== lastNumAsString)) {\n            _onValueChange(getValueObject(formattedValue, numAsString), {\n                event: undefined,\n                source: SourceType.props\n            });\n        }\n    }, [\n        formattedValue,\n        numAsString\n    ]);\n    // also if formatted value is changed from the props, we need to update the caret position\n    // keep the last caret position if element is focused\n    var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : undefined;\n    // needed to prevent warning with useLayoutEffect on server\n    var useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n    useIsomorphicLayoutEffect(function() {\n        var input = focusedElm.current;\n        if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {\n            var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);\n            /**\n             * set the value imperatively, as we set the caret position as well imperatively.\n             * This is to keep value and caret position in sync\n             */ input.value = formattedValue;\n            setPatchedCaretPosition(input, caretPos, formattedValue);\n        }\n    }, [\n        formattedValue\n    ]);\n    var formatInputValue = function(inputValue, event, source) {\n        var changeRange = findChangeRange(formattedValue, inputValue);\n        var changeMeta = Object.assign(Object.assign({}, changeRange), {\n            lastValue: formattedValue\n        });\n        var _numAsString = removeFormatting(inputValue, changeMeta);\n        var _formattedValue = _format(_numAsString);\n        // formatting can remove some of the number chars, so we need to fine number string again\n        _numAsString = removeFormatting(_formattedValue, undefined);\n        if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {\n            //reset the caret position\n            var input = event.target;\n            var currentCaretPosition = geInputCaretPosition(input);\n            var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition);\n            input.value = formattedValue;\n            setPatchedCaretPosition(input, caretPos, formattedValue);\n            return false;\n        }\n        updateValueAndCaretPosition({\n            formattedValue: _formattedValue,\n            numAsString: _numAsString,\n            inputValue: inputValue,\n            event: event,\n            source: source,\n            input: event.target\n        });\n        return true;\n    };\n    var _onChange = function(e) {\n        var el = e.target;\n        var inputValue = el.value;\n        var changed = formatInputValue(inputValue, e, SourceType.event);\n        if (changed) {\n            onChange(e);\n        }\n    };\n    var _onKeyDown = function(e) {\n        var el = e.target;\n        var key = e.key;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        var expectedCaretPosition;\n        //Handle backspace and delete against non numerical/decimal characters or arrow keys\n        if (key === \"ArrowLeft\" || key === \"Backspace\") {\n            expectedCaretPosition = Math.max(selectionStart - 1, 0);\n        } else if (key === \"ArrowRight\") {\n            expectedCaretPosition = Math.min(selectionStart + 1, value.length);\n        } else if (key === \"Delete\") {\n            expectedCaretPosition = selectionStart;\n        }\n        //if expectedCaretPosition is not set it means we don't want to Handle keyDown\n        // also if multiple characters are selected don't handle\n        if (expectedCaretPosition === undefined || selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        var newCaretPosition = expectedCaretPosition;\n        if (key === \"ArrowLeft\" || key === \"ArrowRight\") {\n            var direction = key === \"ArrowLeft\" ? \"left\" : \"right\";\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);\n            // arrow left or right only moves the caret, so no need to handle the event, if we are handling it manually\n            if (newCaretPosition !== expectedCaretPosition) {\n                e.preventDefault();\n            }\n        } else if (key === \"Delete\" && !isValidInputCharacter(value[expectedCaretPosition])) {\n            // in case of delete go to closest caret boundary on the right side\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, \"right\");\n        } else if (key === \"Backspace\" && !isValidInputCharacter(value[expectedCaretPosition])) {\n            // in case of backspace go to closest caret boundary on the left side\n            newCaretPosition = correctCaretPosition(value, expectedCaretPosition, \"left\");\n        }\n        if (newCaretPosition !== expectedCaretPosition) {\n            setPatchedCaretPosition(el, newCaretPosition, value);\n        }\n        /* NOTE: this is just required for unit test as we need to get the newCaretPosition,\n                Remove this when you find different solution */ /* @ts-ignore */ if (e.isUnitTestRun) {\n            setPatchedCaretPosition(el, newCaretPosition, value);\n        }\n        onKeyDown(e);\n    };\n    /** required to handle the caret position when click anywhere within the input **/ var _onMouseUp = function(e) {\n        var el = e.target;\n        /**\n         * NOTE: we have to give default value for value as in case when custom input is provided\n         * value can come as undefined when nothing is provided on value prop.\n         */ var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        if (selectionStart === selectionEnd) {\n            var caretPosition = correctCaretPosition(value, selectionStart);\n            if (caretPosition !== selectionStart) {\n                setPatchedCaretPosition(el, caretPosition, value);\n            }\n        }\n        onMouseUp(e);\n    };\n    var _onFocus = function(e) {\n        // Workaround Chrome and Safari bug https://bugs.chromium.org/p/chromium/issues/detail?id=779328\n        // (onFocus event target selectionStart is always 0 before setTimeout)\n        if (e.persist) {\n            e.persist();\n        }\n        var el = e.target;\n        var currentTarget = e.currentTarget;\n        focusedElm.current = el;\n        timeout.current.focusTimeout = setTimeout(function() {\n            var selectionStart = el.selectionStart;\n            var selectionEnd = el.selectionEnd;\n            var value = el.value;\n            if (value === void 0) value = \"\";\n            var caretPosition = correctCaretPosition(value, selectionStart);\n            //setPatchedCaretPosition only when everything is not selected on focus (while tabbing into the field)\n            if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {\n                setPatchedCaretPosition(el, caretPosition, value);\n            }\n            onFocus(Object.assign(Object.assign({}, e), {\n                currentTarget: currentTarget\n            }));\n        }, 0);\n    };\n    var _onBlur = function(e) {\n        focusedElm.current = null;\n        clearTimeout(timeout.current.focusTimeout);\n        clearTimeout(timeout.current.setCaretTimeout);\n        onBlur(e);\n    };\n    // add input mode on element based on format prop and device once the component is mounted\n    var inputMode = mounted && addInputMode() ? \"numeric\" : undefined;\n    var inputProps = Object.assign({\n        inputMode: inputMode\n    }, otherProps, {\n        type: type,\n        value: formattedValue,\n        onChange: _onChange,\n        onKeyDown: _onKeyDown,\n        onMouseUp: _onMouseUp,\n        onFocus: _onFocus,\n        onBlur: _onBlur\n    });\n    if (displayType === \"text\") {\n        return renderText ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, renderText(formattedValue, otherProps) || null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", Object.assign({}, otherProps, {\n            ref: getInputRef\n        }), formattedValue);\n    } else if (customInput) {\n        var CustomInput = customInput;\n        /* @ts-ignore */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, Object.assign({}, inputProps, {\n            ref: getInputRef\n        }));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", Object.assign({}, inputProps, {\n        ref: getInputRef\n    }));\n}\nfunction format(numStr, props) {\n    var decimalScale = props.decimalScale;\n    var fixedDecimalScale = props.fixedDecimalScale;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var allowNegative = props.allowNegative;\n    var thousandsGroupStyle = props.thousandsGroupStyle;\n    if (thousandsGroupStyle === void 0) thousandsGroupStyle = \"thousand\";\n    // don't apply formatting on empty string or '-'\n    if (numStr === \"\" || numStr === \"-\") {\n        return numStr;\n    }\n    var ref = getSeparators(props);\n    var thousandSeparator = ref.thousandSeparator;\n    var decimalSeparator = ref.decimalSeparator;\n    /**\n     * Keep the decimal separator\n     * when decimalScale is not defined or non zero and the numStr has decimal in it\n     * Or if decimalScale is > 0 and fixeDecimalScale is true (even if numStr has no decimal)\n     */ var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(\".\") !== -1 || decimalScale && fixedDecimalScale;\n    var ref$1 = splitDecimal(numStr, allowNegative);\n    var beforeDecimal = ref$1.beforeDecimal;\n    var afterDecimal = ref$1.afterDecimal;\n    var addNegation = ref$1.addNegation; // eslint-disable-line prefer-const\n    //apply decimal precision if its defined\n    if (decimalScale !== undefined) {\n        afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);\n    }\n    if (thousandSeparator) {\n        beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);\n    }\n    //add prefix and suffix when there is a number present\n    if (prefix) {\n        beforeDecimal = prefix + beforeDecimal;\n    }\n    if (suffix) {\n        afterDecimal = afterDecimal + suffix;\n    }\n    //restore negation sign\n    if (addNegation) {\n        beforeDecimal = \"-\" + beforeDecimal;\n    }\n    numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || \"\") + afterDecimal;\n    return numStr;\n}\nfunction getSeparators(props) {\n    var decimalSeparator = props.decimalSeparator;\n    if (decimalSeparator === void 0) decimalSeparator = \".\";\n    var thousandSeparator = props.thousandSeparator;\n    var allowedDecimalSeparators = props.allowedDecimalSeparators;\n    if (thousandSeparator === true) {\n        thousandSeparator = \",\";\n    }\n    if (!allowedDecimalSeparators) {\n        allowedDecimalSeparators = [\n            decimalSeparator,\n            \".\"\n        ];\n    }\n    return {\n        decimalSeparator: decimalSeparator,\n        thousandSeparator: thousandSeparator,\n        allowedDecimalSeparators: allowedDecimalSeparators\n    };\n}\nfunction handleNegation(value, allowNegative) {\n    if (value === void 0) value = \"\";\n    var negationRegex = new RegExp(\"(-)\");\n    var doubleNegationRegex = new RegExp(\"(-)(.)*(-)\");\n    // Check number has '-' value\n    var hasNegation = negationRegex.test(value);\n    // Check number has 2 or more '-' values\n    var removeNegation = doubleNegationRegex.test(value);\n    //remove negation\n    value = value.replace(/-/g, \"\");\n    if (hasNegation && !removeNegation && allowNegative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction getNumberRegex(decimalSeparator, global) {\n    return new RegExp(\"(^-)|[0-9]|\" + escapeRegExp(decimalSeparator), global ? \"g\" : undefined);\n}\nfunction isNumericString(val, prefix, suffix) {\n    // for empty value we can always treat it as numeric string\n    if (val === \"\") {\n        return true;\n    }\n    return !(prefix === null || prefix === void 0 ? void 0 : prefix.match(/\\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\\d/)) && typeof val === \"string\" && !isNaN(Number(val));\n}\nfunction removeFormatting(value, changeMeta, props) {\n    var assign;\n    if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);\n    var allowNegative = props.allowNegative;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var decimalScale = props.decimalScale;\n    var from = changeMeta.from;\n    var to = changeMeta.to;\n    var start = to.start;\n    var end = to.end;\n    var ref = getSeparators(props);\n    var allowedDecimalSeparators = ref.allowedDecimalSeparators;\n    var decimalSeparator = ref.decimalSeparator;\n    var isBeforeDecimalSeparator = value[end] === decimalSeparator;\n    /**\n     * If only a number is added on empty input which matches with the prefix or suffix,\n     * then don't remove it, just return the same\n     */ if (charIsNumber(value) && (value === prefix || value === suffix) && changeMeta.lastValue === \"\") {\n        return value;\n    }\n    /** Check for any allowed decimal separator is added in the numeric format and replace it with decimal separator */ if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {\n        var separator = decimalScale === 0 ? \"\" : decimalSeparator;\n        value = value.substring(0, start) + separator + value.substring(start + 1, value.length);\n    }\n    var stripNegation = function(value, start, end) {\n        /**\n         * if prefix starts with - we don't allow negative number to avoid confusion\n         * if suffix starts with - and the value length is same as suffix length, then the - sign is from the suffix\n         * In other cases, if the value starts with - then it is a negation\n         */ var hasNegation = false;\n        var hasDoubleNegation = false;\n        if (prefix.startsWith(\"-\")) {\n            hasNegation = false;\n        } else if (value.startsWith(\"--\")) {\n            hasNegation = false;\n            hasDoubleNegation = true;\n        } else if (suffix.startsWith(\"-\") && value.length === suffix.length) {\n            hasNegation = false;\n        } else if (value[0] === \"-\") {\n            hasNegation = true;\n        }\n        var charsToRemove = hasNegation ? 1 : 0;\n        if (hasDoubleNegation) {\n            charsToRemove = 2;\n        }\n        // remove negation/double negation from start to simplify prefix logic as negation comes before prefix\n        if (charsToRemove) {\n            value = value.substring(charsToRemove);\n            // account for the removal of the negation for start and end index\n            start -= charsToRemove;\n            end -= charsToRemove;\n        }\n        return {\n            value: value,\n            start: start,\n            end: end,\n            hasNegation: hasNegation\n        };\n    };\n    var toMetadata = stripNegation(value, start, end);\n    var hasNegation = toMetadata.hasNegation;\n    assign = toMetadata, value = assign.value, start = assign.start, end = assign.end;\n    var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);\n    var fromStart = ref$1.start;\n    var fromEnd = ref$1.end;\n    var lastValue = ref$1.value;\n    // if only prefix and suffix part is updated reset the value to last value\n    // if the changed range is from suffix in the updated value, and the the suffix starts with the same characters, allow the change\n    var updatedSuffixPart = value.substring(start, end);\n    if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {\n        value = lastValue;\n    }\n    /**\n     * remove prefix\n     * Remove whole prefix part if its present on the value\n     * If the prefix is partially deleted (in which case change start index will be less the prefix length)\n     * Remove only partial part of prefix.\n     */ var startIndex = 0;\n    if (value.startsWith(prefix)) {\n        startIndex += prefix.length;\n    } else if (start < prefix.length) {\n        startIndex = start;\n    }\n    value = value.substring(startIndex);\n    // account for deleted prefix for end\n    end -= startIndex;\n    /**\n     * Remove suffix\n     * Remove whole suffix part if its present on the value\n     * If the suffix is partially deleted (in which case change end index will be greater than the suffixStartIndex)\n     * remove the partial part of suffix\n     */ var endIndex = value.length;\n    var suffixStartIndex = value.length - suffix.length;\n    if (value.endsWith(suffix)) {\n        endIndex = suffixStartIndex;\n    } else if (end > suffixStartIndex) {\n        endIndex = end;\n    } else if (end > value.length - suffix.length) {\n        endIndex = end;\n    }\n    value = value.substring(0, endIndex);\n    // add the negation back and handle for double negation\n    value = handleNegation(hasNegation ? \"-\" + value : value, allowNegative);\n    // remove non numeric characters\n    value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join(\"\");\n    // replace the decimalSeparator with ., and only keep the first separator, ignore following ones\n    var firstIndex = value.indexOf(decimalSeparator);\n    value = value.replace(new RegExp(escapeRegExp(decimalSeparator), \"g\"), function(match, index) {\n        return index === firstIndex ? \".\" : \"\";\n    });\n    //check if beforeDecimal got deleted and there is nothing after decimal,\n    //clear all numbers in such case while keeping the - sign\n    var ref$2 = splitDecimal(value, allowNegative);\n    var beforeDecimal = ref$2.beforeDecimal;\n    var afterDecimal = ref$2.afterDecimal;\n    var addNegation = ref$2.addNegation; // eslint-disable-line prefer-const\n    //clear only if something got deleted before decimal (cursor is before decimal)\n    if (to.end - to.start < from.end - from.start && beforeDecimal === \"\" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {\n        value = addNegation ? \"-\" : \"\";\n    }\n    return value;\n}\nfunction getCaretBoundary(formattedValue, props) {\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var suffix = props.suffix;\n    if (suffix === void 0) suffix = \"\";\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    var hasNegation = formattedValue[0] === \"-\";\n    // fill for prefix and negation\n    boundaryAry.fill(false, 0, prefix.length + (hasNegation ? 1 : 0));\n    // fill for suffix\n    var valLn = formattedValue.length;\n    boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);\n    return boundaryAry;\n}\nfunction validateAndUpdateProps(props) {\n    var ref = getSeparators(props);\n    var thousandSeparator = ref.thousandSeparator;\n    var decimalSeparator = ref.decimalSeparator;\n    // eslint-disable-next-line prefer-const\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var allowNegative = props.allowNegative;\n    if (allowNegative === void 0) allowNegative = true;\n    if (thousandSeparator === decimalSeparator) {\n        throw new Error(\"\\n        Decimal separator can't be same as thousand separator.\\n        thousandSeparator: \" + thousandSeparator + ' (thousandSeparator = {true} is same as thousandSeparator = \",\")\\n        decimalSeparator: ' + decimalSeparator + \" (default value for decimalSeparator is .)\\n     \");\n    }\n    if (prefix.startsWith(\"-\") && allowNegative) {\n        // TODO: throw error in next major version\n        console.error(\"\\n      Prefix can't start with '-' when allowNegative is true.\\n      prefix: \" + prefix + \"\\n      allowNegative: \" + allowNegative + \"\\n    \");\n        allowNegative = false;\n    }\n    return Object.assign(Object.assign({}, props), {\n        allowNegative: allowNegative\n    });\n}\nfunction useNumericFormat(props) {\n    // validate props\n    props = validateAndUpdateProps(props);\n    var _decimalSeparator = props.decimalSeparator;\n    var _allowedDecimalSeparators = props.allowedDecimalSeparators;\n    var thousandsGroupStyle = props.thousandsGroupStyle;\n    var suffix = props.suffix;\n    var allowNegative = props.allowNegative;\n    var allowLeadingZeros = props.allowLeadingZeros;\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var onBlur = props.onBlur;\n    if (onBlur === void 0) onBlur = noop;\n    var thousandSeparator = props.thousandSeparator;\n    var decimalScale = props.decimalScale;\n    var fixedDecimalScale = props.fixedDecimalScale;\n    var prefix = props.prefix;\n    if (prefix === void 0) prefix = \"\";\n    var defaultValue = props.defaultValue;\n    var value = props.value;\n    var valueIsNumericString = props.valueIsNumericString;\n    var onValueChange = props.onValueChange;\n    var restProps = __rest(props, [\n        \"decimalSeparator\",\n        \"allowedDecimalSeparators\",\n        \"thousandsGroupStyle\",\n        \"suffix\",\n        \"allowNegative\",\n        \"allowLeadingZeros\",\n        \"onKeyDown\",\n        \"onBlur\",\n        \"thousandSeparator\",\n        \"decimalScale\",\n        \"fixedDecimalScale\",\n        \"prefix\",\n        \"defaultValue\",\n        \"value\",\n        \"valueIsNumericString\",\n        \"onValueChange\"\n    ]);\n    // get derived decimalSeparator and allowedDecimalSeparators\n    var ref = getSeparators(props);\n    var decimalSeparator = ref.decimalSeparator;\n    var allowedDecimalSeparators = ref.allowedDecimalSeparators;\n    var _format = function(numStr) {\n        return format(numStr, props);\n    };\n    var _removeFormatting = function(inputValue, changeMeta) {\n        return removeFormatting(inputValue, changeMeta, props);\n    };\n    var _value = isNil(value) ? defaultValue : value;\n    // try to figure out isValueNumericString based on format prop and value\n    var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix, suffix);\n    if (!isNil(value)) {\n        _valueIsNumericString = _valueIsNumericString || typeof value === \"number\";\n    } else if (!isNil(defaultValue)) {\n        _valueIsNumericString = _valueIsNumericString || typeof defaultValue === \"number\";\n    }\n    var roundIncomingValueToPrecision = function(value) {\n        if (isNotValidValue(value)) {\n            return value;\n        }\n        if (typeof value === \"number\") {\n            value = toNumericString(value);\n        }\n        /**\n         * only round numeric or float string values coming through props,\n         * we don't need to do it for onChange events, as we want to prevent typing there\n         */ if (_valueIsNumericString && typeof decimalScale === \"number\") {\n            return roundToPrecision(value, decimalScale, Boolean(fixedDecimalScale));\n        }\n        return value;\n    };\n    var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);\n    var ref$1_0 = ref$1[0];\n    var numAsString = ref$1_0.numAsString;\n    var formattedValue = ref$1_0.formattedValue;\n    var _onValueChange = ref$1[1];\n    var _onKeyDown = function(e) {\n        var el = e.target;\n        var key = e.key;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        if (value === void 0) value = \"\";\n        // if multiple characters are selected and user hits backspace, no need to handle anything manually\n        if (selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        // if user hits backspace, while the cursor is before prefix, and the input has negation, remove the negation\n        if (key === \"Backspace\" && value[0] === \"-\" && selectionStart === prefix.length + 1 && allowNegative) {\n            // bring the cursor to after negation\n            setCaretPosition(el, 1);\n        }\n        // don't allow user to delete decimal separator when decimalScale and fixedDecimalScale is set\n        if (decimalScale && fixedDecimalScale) {\n            if (key === \"Backspace\" && value[selectionStart - 1] === decimalSeparator) {\n                setCaretPosition(el, selectionStart - 1);\n                e.preventDefault();\n            } else if (key === \"Delete\" && value[selectionStart] === decimalSeparator) {\n                e.preventDefault();\n            }\n        }\n        // if user presses the allowed decimal separator before the separator, move the cursor after the separator\n        if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value[selectionStart] === decimalSeparator) {\n            setCaretPosition(el, selectionStart + 1);\n        }\n        var _thousandSeparator = thousandSeparator === true ? \",\" : thousandSeparator;\n        // move cursor when delete or backspace is pressed before/after thousand separator\n        if (key === \"Backspace\" && value[selectionStart - 1] === _thousandSeparator) {\n            setCaretPosition(el, selectionStart - 1);\n        }\n        if (key === \"Delete\" && value[selectionStart] === _thousandSeparator) {\n            setCaretPosition(el, selectionStart + 1);\n        }\n        onKeyDown(e);\n    };\n    var _onBlur = function(e) {\n        var _value = numAsString;\n        // if there no no numeric value, clear the input\n        if (!_value.match(/\\d/g)) {\n            _value = \"\";\n        }\n        // clear leading 0s\n        if (!allowLeadingZeros) {\n            _value = fixLeadingZero(_value);\n        }\n        // apply fixedDecimalScale on blur event\n        if (fixedDecimalScale && decimalScale) {\n            _value = roundToPrecision(_value, decimalScale, fixedDecimalScale);\n        }\n        if (_value !== numAsString) {\n            var formattedValue = format(_value, props);\n            _onValueChange({\n                formattedValue: formattedValue,\n                value: _value,\n                floatValue: parseFloat(_value)\n            }, {\n                event: e,\n                source: SourceType.event\n            });\n        }\n        onBlur(e);\n    };\n    var isValidInputCharacter = function(inputChar) {\n        if (inputChar === decimalSeparator) {\n            return true;\n        }\n        return charIsNumber(inputChar);\n    };\n    var isCharacterSame = function(ref) {\n        var currentValue = ref.currentValue;\n        var lastValue = ref.lastValue;\n        var formattedValue = ref.formattedValue;\n        var currentValueIndex = ref.currentValueIndex;\n        var formattedValueIndex = ref.formattedValueIndex;\n        var curChar = currentValue[currentValueIndex];\n        var newChar = formattedValue[formattedValueIndex];\n        /**\n         * NOTE: as thousand separator and allowedDecimalSeparators can be same, we need to check on\n         * typed range if we have typed any character from allowedDecimalSeparators, in that case we\n         * consider different characters like , and . same within the range of updated value.\n         */ var typedRange = findChangeRange(lastValue, currentValue);\n        var to = typedRange.to;\n        if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) {\n            return true;\n        }\n        return curChar === newChar;\n    };\n    return Object.assign(Object.assign({}, restProps), {\n        value: formattedValue,\n        valueIsNumericString: false,\n        isValidInputCharacter: isValidInputCharacter,\n        isCharacterSame: isCharacterSame,\n        onValueChange: _onValueChange,\n        format: _format,\n        removeFormatting: _removeFormatting,\n        getCaretBoundary: function(formattedValue) {\n            return getCaretBoundary(formattedValue, props);\n        },\n        onKeyDown: _onKeyDown,\n        onBlur: _onBlur\n    });\n}\nfunction NumericFormat(props) {\n    var numericFormatProps = useNumericFormat(props);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NumberFormatBase, Object.assign({}, numericFormatProps));\n}\nfunction format$1(numStr, props) {\n    var format = props.format;\n    var allowEmptyFormatting = props.allowEmptyFormatting;\n    var mask = props.mask;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    if (numStr === \"\" && !allowEmptyFormatting) {\n        return \"\";\n    }\n    var hashCount = 0;\n    var formattedNumberAry = format.split(\"\");\n    for(var i = 0, ln = format.length; i < ln; i++){\n        if (format[i] === patternChar) {\n            formattedNumberAry[i] = numStr[hashCount] || getMaskAtIndex(mask, hashCount);\n            hashCount += 1;\n        }\n    }\n    return formattedNumberAry.join(\"\");\n}\nfunction removeFormatting$1(value, changeMeta, props) {\n    if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);\n    var format = props.format;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var from = changeMeta.from;\n    var to = changeMeta.to;\n    var lastValue = changeMeta.lastValue;\n    if (lastValue === void 0) lastValue = \"\";\n    var isNumericSlot = function(caretPos) {\n        return format[caretPos] === patternChar;\n    };\n    var removeFormatChar = function(string, startIndex) {\n        var str = \"\";\n        for(var i = 0; i < string.length; i++){\n            if (isNumericSlot(startIndex + i) && charIsNumber(string[i])) {\n                str += string[i];\n            }\n        }\n        return str;\n    };\n    var extractNumbers = function(str) {\n        return str.replace(/[^0-9]/g, \"\");\n    };\n    // if format doesn't have any number, remove all the non numeric characters\n    if (!format.match(/\\d/)) {\n        return extractNumbers(value);\n    }\n    /**\n     * if user paste the whole formatted text in an empty input, check if matches to the pattern\n     * and remove the format characters, if there is a mismatch on the pattern, do plane number extract\n     */ if (lastValue === \"\" && value.length === format.length) {\n        var str = \"\";\n        for(var i = 0; i < value.length; i++){\n            if (isNumericSlot(i)) {\n                if (charIsNumber(value[i])) {\n                    str += value[i];\n                }\n            } else if (value[i] !== format[i]) {\n                // if there is a mismatch on the pattern, do plane number extract\n                return extractNumbers(value);\n            }\n        }\n        return str;\n    }\n    /**\n     * For partial change,\n     * where ever there is a change on the input, we can break the number in three parts\n     * 1st: left part which is unchanged\n     * 2nd: middle part which is changed\n     * 3rd: right part which is unchanged\n     *\n     * The first and third section will be same as last value, only the middle part will change\n     * We can consider on the change part all the new characters are non format characters.\n     * And on the first and last section it can have partial format characters.\n     *\n     * We pick first and last section from the lastValue (as that has 1-1 mapping with format)\n     * and middle one from the update value.\n     */ var firstSection = lastValue.substring(0, from.start);\n    var middleSection = value.substring(to.start, to.end);\n    var lastSection = lastValue.substring(from.end);\n    return \"\" + removeFormatChar(firstSection, 0) + extractNumbers(middleSection) + removeFormatChar(lastSection, from.end);\n}\nfunction getCaretBoundary$1(formattedValue, props) {\n    var format = props.format;\n    var mask = props.mask;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var boundaryAry = Array.from({\n        length: formattedValue.length + 1\n    }).map(function() {\n        return true;\n    });\n    var hashCount = 0;\n    var firstEmptySlot = -1;\n    var maskAndIndexMap = {};\n    format.split(\"\").forEach(function(char, index) {\n        var maskAtIndex = undefined;\n        if (char === patternChar) {\n            hashCount++;\n            maskAtIndex = getMaskAtIndex(mask, hashCount - 1);\n            if (firstEmptySlot === -1 && formattedValue[index] === maskAtIndex) {\n                firstEmptySlot = index;\n            }\n        }\n        maskAndIndexMap[index] = maskAtIndex;\n    });\n    var isPosAllowed = function(pos) {\n        // the position is allowed if the position is not masked and valid number area\n        return format[pos] === patternChar && formattedValue[pos] !== maskAndIndexMap[pos];\n    };\n    for(var i = 0, ln = boundaryAry.length; i < ln; i++){\n        // consider caret to be in boundary if it is before or after numeric value\n        // Note: on pattern based format its denoted by patternCharacter\n        // we should also allow user to put cursor on first empty slot\n        boundaryAry[i] = i === firstEmptySlot || isPosAllowed(i) || isPosAllowed(i - 1);\n    }\n    // the first patternChar position is always allowed\n    boundaryAry[format.indexOf(patternChar)] = true;\n    return boundaryAry;\n}\nfunction validateProps(props) {\n    var mask = props.mask;\n    if (mask) {\n        var maskAsStr = mask === \"string\" ? mask : mask.toString();\n        if (maskAsStr.match(/\\d/g)) {\n            throw new Error(\"Mask \" + mask + \" should not contain numeric character;\");\n        }\n    }\n}\nfunction isNumericString$1(val, format) {\n    //we can treat empty string as numeric string\n    if (val === \"\") {\n        return true;\n    }\n    return !(format === null || format === void 0 ? void 0 : format.match(/\\d/)) && typeof val === \"string\" && (!!val.match(/^\\d+$/) || val === \"\");\n}\nfunction usePatternFormat(props) {\n    var mask = props.mask;\n    var allowEmptyFormatting = props.allowEmptyFormatting;\n    var formatProp = props.format;\n    var inputMode = props.inputMode;\n    if (inputMode === void 0) inputMode = \"numeric\";\n    var onKeyDown = props.onKeyDown;\n    if (onKeyDown === void 0) onKeyDown = noop;\n    var patternChar = props.patternChar;\n    if (patternChar === void 0) patternChar = \"#\";\n    var value = props.value;\n    var defaultValue = props.defaultValue;\n    var valueIsNumericString = props.valueIsNumericString;\n    var restProps = __rest(props, [\n        \"mask\",\n        \"allowEmptyFormatting\",\n        \"format\",\n        \"inputMode\",\n        \"onKeyDown\",\n        \"patternChar\",\n        \"value\",\n        \"defaultValue\",\n        \"valueIsNumericString\"\n    ]);\n    // validate props\n    validateProps(props);\n    var _getCaretBoundary = function(formattedValue) {\n        return getCaretBoundary$1(formattedValue, props);\n    };\n    var _onKeyDown = function(e) {\n        var key = e.key;\n        var el = e.target;\n        var selectionStart = el.selectionStart;\n        var selectionEnd = el.selectionEnd;\n        var value = el.value;\n        // if multiple characters are selected and user hits backspace, no need to handle anything manually\n        if (selectionStart !== selectionEnd) {\n            onKeyDown(e);\n            return;\n        }\n        // bring the cursor to closest numeric section\n        var caretPos = selectionStart;\n        // if backspace is pressed after the format characters, bring it to numeric section\n        // if delete is pressed before the format characters, bring it to numeric section\n        if (key === \"Backspace\" || key === \"Delete\") {\n            var direction = \"right\";\n            if (key === \"Backspace\") {\n                while(caretPos > 0 && formatProp[caretPos - 1] !== patternChar){\n                    caretPos--;\n                }\n                direction = \"left\";\n            } else {\n                var formatLn = formatProp.length;\n                while(caretPos < formatLn && formatProp[caretPos] !== patternChar){\n                    caretPos++;\n                }\n                direction = \"right\";\n            }\n            caretPos = getCaretPosInBoundary(value, caretPos, _getCaretBoundary(value), direction);\n        } else if (formatProp[caretPos] !== patternChar && key !== \"ArrowLeft\" && key !== \"ArrowRight\") {\n            // if user is typing on format character position, bring user to next allowed caret position\n            caretPos = getCaretPosInBoundary(value, caretPos + 1, _getCaretBoundary(value), \"right\");\n        }\n        // if we changing caret position, set the caret position\n        if (caretPos !== selectionStart) {\n            setCaretPosition(el, caretPos);\n        }\n        onKeyDown(e);\n    };\n    // try to figure out isValueNumericString based on format prop and value\n    var _value = isNil(value) ? defaultValue : value;\n    var isValueNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString$1(_value, formatProp);\n    var _props = Object.assign(Object.assign({}, props), {\n        valueIsNumericString: isValueNumericString\n    });\n    return Object.assign(Object.assign({}, restProps), {\n        value: value,\n        defaultValue: defaultValue,\n        valueIsNumericString: isValueNumericString,\n        inputMode: inputMode,\n        format: function(numStr) {\n            return format$1(numStr, _props);\n        },\n        removeFormatting: function(inputValue, changeMeta) {\n            return removeFormatting$1(inputValue, changeMeta, _props);\n        },\n        getCaretBoundary: _getCaretBoundary,\n        onKeyDown: _onKeyDown\n    });\n}\nfunction PatternFormat(props) {\n    var patternFormatProps = usePatternFormat(props);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NumberFormatBase, Object.assign({}, patternFormatProps));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbnVtYmVyLWZvcm1hdC9kaXN0L3JlYWN0LW51bWJlci1mb3JtYXQuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRW9GO0FBRXJGOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTTSxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHO1FBQUUsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQ2hGO1lBQUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7UUFBRTtJQUFFO0lBQ3JCLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRDtRQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1lBQ3RFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekU7Z0JBQUVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztZQUFFO1FBQzdCO0lBQUU7SUFDTixPQUFPUjtBQUNYO0FBRUEsSUFBSVc7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0lBQ3RCQSxVQUFVLENBQUMsUUFBUSxHQUFHO0FBQzFCLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUVoQyxzQkFBc0I7QUFDdEIs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SUFDeEIsSUFBSWtKLHFCQUFxQlAsaUJBQWlCM0k7SUFDMUMscUJBQU8vTCwwREFBbUIsQ0FBQzhMLGtCQUFrQm5MLE9BQU9rTyxNQUFNLENBQUMsQ0FBQyxHQUFHb0c7QUFDbkU7QUFFd1UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYW50aW5lLW1pbmltYWwtbmV4dC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1udW1iZXItZm9ybWF0L2Rpc3QvcmVhY3QtbnVtYmVyLWZvcm1hdC5lcy5qcz8zNDdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3QtbnVtYmVyLWZvcm1hdCAtIDUuMy4zXG4gKiBBdXRob3IgOiBTdWRoYW5zaHUgWWFkYXZcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgMjAyNCB0byBTdWRoYW5zaHUgWWFkYXYsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zLXlhZGF2L3JlYWN0LW51bWJlci1mb3JtYXRcbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHsgdFtwXSA9IHNbcF07IH0gfVxyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIHsgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB7IHRbcFtpXV0gPSBzW3BbaV1dOyB9XHJcbiAgICAgICAgfSB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG52YXIgU291cmNlVHlwZTtcbihmdW5jdGlvbiAoU291cmNlVHlwZSkge1xuICAgIFNvdXJjZVR5cGVbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTb3VyY2VUeXBlW1wicHJvcHNcIl0gPSBcInByb3BcIjtcbn0pKFNvdXJjZVR5cGUgfHwgKFNvdXJjZVR5cGUgPSB7fSkpO1xuXG4vLyBiYXNpYyBub29wIGZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG5mdW5jdGlvbiBtZW1vaXplT25jZShjYikge1xuICAgIHZhciBsYXN0QXJncztcbiAgICB2YXIgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgaWYgKGxhc3RBcmdzICYmXG4gICAgICAgICAgICBhcmdzLmxlbmd0aCA9PT0gbGFzdEFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICBhcmdzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIHZhbHVlID09PSBsYXN0QXJnc1tpbmRleF07IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgICAgbGFzdFZhbHVlID0gY2IuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhcklzTnVtYmVyKGNoYXIpIHtcbiAgICByZXR1cm4gISEoY2hhciB8fCAnJykubWF0Y2goL1xcZC8pO1xufVxuZnVuY3Rpb24gaXNOaWwodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTmFuVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCk7XG59XG5mdW5jdGlvbiBpc05vdFZhbGlkVmFsdWUodmFsKSB7XG4gICAgcmV0dXJuIGlzTmlsKHZhbCkgfHwgaXNOYW5WYWx1ZSh2YWwpIHx8ICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUodmFsKSk7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVtcXF0ve30oKSorPy5cXFxcXiR8XS9nLCAnXFxcXCQmJyk7XG59XG5mdW5jdGlvbiBnZXRUaG91c2FuZHNHcm91cFJlZ2V4KHRob3VzYW5kc0dyb3VwU3R5bGUpIHtcbiAgICBzd2l0Y2ggKHRob3VzYW5kc0dyb3VwU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnbGFraCc6XG4gICAgICAgICAgICByZXR1cm4gLyhcXGQrPykoPz0oXFxkXFxkKSsoXFxkKSg/IVxcZCkpKFxcLlxcZCspPy9nO1xuICAgICAgICBjYXNlICd3YW4nOlxuICAgICAgICAgICAgcmV0dXJuIC8oXFxkKSg/PShcXGR7NH0pKyg/IVxcZCkpL2c7XG4gICAgICAgIGNhc2UgJ3Rob3VzYW5kJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VGhvdXNhbmRTZXBhcmF0b3Ioc3RyLCB0aG91c2FuZFNlcGFyYXRvciwgdGhvdXNhbmRzR3JvdXBTdHlsZSkge1xuICAgIHZhciB0aG91c2FuZHNHcm91cFJlZ2V4ID0gZ2V0VGhvdXNhbmRzR3JvdXBSZWdleCh0aG91c2FuZHNHcm91cFN0eWxlKTtcbiAgICB2YXIgaW5kZXggPSBzdHIuc2VhcmNoKC9bMS05XS8pO1xuICAgIGluZGV4ID0gaW5kZXggPT09IC0xID8gc3RyLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiAoc3RyLnN1YnN0cmluZygwLCBpbmRleCkgK1xuICAgICAgICBzdHIuc3Vic3RyaW5nKGluZGV4LCBzdHIubGVuZ3RoKS5yZXBsYWNlKHRob3VzYW5kc0dyb3VwUmVnZXgsICckMScgKyB0aG91c2FuZFNlcGFyYXRvcikpO1xufVxuZnVuY3Rpb24gdXNlUGVyc2lzdGVudENhbGxiYWNrKGNiKSB7XG4gICAgdmFyIGNhbGxiYWNrUmVmID0gdXNlUmVmKGNiKTtcbiAgICAvLyBrZWVwIHRoZSBjYWxsYmFjayByZWYgdXB0byBkYXRlXG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNiO1xuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgYSBwZXJzaXN0ZW50IGNhbGxiYWNrIHdoaWNoIG5ldmVyIGNoYW5nZXNcbiAgICAgKiB0aHJvdWdoIG91dCB0aGUgY29tcG9uZW50IGxpZmVjeWNsZVxuICAgICAqL1xuICAgIHZhciBwZXJzaXN0ZW50Q2JSZWYgPSB1c2VSZWYoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBjYWxsYmFja1JlZi5jdXJyZW50LmFwcGx5KGNhbGxiYWNrUmVmLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGVyc2lzdGVudENiUmVmLmN1cnJlbnQ7XG59XG4vL3NwaWx0IGEgZmxvYXQgbnVtYmVyIGludG8gZGlmZmVyZW50IHBhcnRzIGJlZm9yZURlY2ltYWwsIGFmdGVyRGVjaW1hbCwgYW5kIG5lZ2F0aW9uXG5mdW5jdGlvbiBzcGxpdERlY2ltYWwobnVtU3RyLCBhbGxvd05lZ2F0aXZlKSB7XG4gICAgaWYgKCBhbGxvd05lZ2F0aXZlID09PSB2b2lkIDAgKSBhbGxvd05lZ2F0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBoYXNOZWdhdGlvbiA9IG51bVN0clswXSA9PT0gJy0nO1xuICAgIHZhciBhZGROZWdhdGlvbiA9IGhhc05lZ2F0aW9uICYmIGFsbG93TmVnYXRpdmU7XG4gICAgbnVtU3RyID0gbnVtU3RyLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgdmFyIHBhcnRzID0gbnVtU3RyLnNwbGl0KCcuJyk7XG4gICAgdmFyIGJlZm9yZURlY2ltYWwgPSBwYXJ0c1swXTtcbiAgICB2YXIgYWZ0ZXJEZWNpbWFsID0gcGFydHNbMV0gfHwgJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlRGVjaW1hbDogYmVmb3JlRGVjaW1hbCxcbiAgICAgICAgYWZ0ZXJEZWNpbWFsOiBhZnRlckRlY2ltYWwsXG4gICAgICAgIGhhc05lZ2F0aW9uOiBoYXNOZWdhdGlvbixcbiAgICAgICAgYWRkTmVnYXRpb246IGFkZE5lZ2F0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiBmaXhMZWFkaW5nWmVybyhudW1TdHIpIHtcbiAgICBpZiAoIW51bVN0cilcbiAgICAgICAgeyByZXR1cm4gbnVtU3RyOyB9XG4gICAgdmFyIGlzTmVnYXRpdmUgPSBudW1TdHJbMF0gPT09ICctJztcbiAgICBpZiAoaXNOZWdhdGl2ZSlcbiAgICAgICAgeyBudW1TdHIgPSBudW1TdHIuc3Vic3RyaW5nKDEsIG51bVN0ci5sZW5ndGgpOyB9XG4gICAgdmFyIHBhcnRzID0gbnVtU3RyLnNwbGl0KCcuJyk7XG4gICAgdmFyIGJlZm9yZURlY2ltYWwgPSBwYXJ0c1swXS5yZXBsYWNlKC9eMCsvLCAnJykgfHwgJzAnO1xuICAgIHZhciBhZnRlckRlY2ltYWwgPSBwYXJ0c1sxXSB8fCAnJztcbiAgICByZXR1cm4gKFwiXCIgKyAoaXNOZWdhdGl2ZSA/ICctJyA6ICcnKSArIGJlZm9yZURlY2ltYWwgKyAoYWZ0ZXJEZWNpbWFsID8gKFwiLlwiICsgYWZ0ZXJEZWNpbWFsKSA6ICcnKSk7XG59XG4vKipcbiAqIGxpbWl0IGRlY2ltYWwgbnVtYmVycyB0byBnaXZlbiBzY2FsZVxuICogTm90IHVzZWQgLmZpeGVkVG8gYmVjYXVzZSB0aGF0IHdpbGwgYnJlYWsgd2l0aCBiaWcgbnVtYmVyc1xuICovXG5mdW5jdGlvbiBsaW1pdFRvU2NhbGUobnVtU3RyLCBzY2FsZSwgZml4ZWREZWNpbWFsU2NhbGUpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIGZpbGxlciA9IGZpeGVkRGVjaW1hbFNjYWxlID8gJzAnIDogJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2NhbGUgLSAxOyBpKyspIHtcbiAgICAgICAgc3RyICs9IG51bVN0cltpXSB8fCBmaWxsZXI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICAgIHJldHVybiBBcnJheShjb3VudCArIDEpLmpvaW4oc3RyKTtcbn1cbmZ1bmN0aW9uIHRvTnVtZXJpY1N0cmluZyhudW0pIHtcbiAgICB2YXIgX251bSA9IG51bSArICcnOyAvLyB0eXBlY2FzdCBudW1iZXIgdG8gc3RyaW5nXG4gICAgLy8gc3RvcmUgdGhlIHNpZ24gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBudW1iZXIuXG4gICAgdmFyIHNpZ24gPSBfbnVtWzBdID09PSAnLScgPyAnLScgOiAnJztcbiAgICBpZiAoc2lnbilcbiAgICAgICAgeyBfbnVtID0gX251bS5zdWJzdHJpbmcoMSk7IH1cbiAgICAvLyBzcGxpdCB0aGUgbnVtYmVyIGludG8gY29mZmljaWVudCBhbmQgZXhwb25lbnRcbiAgICB2YXIgcmVmID0gX251bS5zcGxpdCgvW2VFXS9nKTtcbiAgICB2YXIgY29lZmZpY2llbnQgPSByZWZbMF07XG4gICAgdmFyIGV4cG9uZW50ID0gcmVmWzFdO1xuICAgIC8vIGNvdmVydCBleHBvbmVudCB0byBudW1iZXI7XG4gICAgZXhwb25lbnQgPSBOdW1iZXIoZXhwb25lbnQpO1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGV4cG9uZW50IHBhcnQgb3IgaXRzIDAsIHJldHVybiB0aGUgY29mZmllY2llbnQgd2l0aCBzaWduXG4gICAgaWYgKCFleHBvbmVudClcbiAgICAgICAgeyByZXR1cm4gc2lnbiArIGNvZWZmaWNpZW50OyB9XG4gICAgY29lZmZpY2llbnQgPSBjb2VmZmljaWVudC5yZXBsYWNlKCcuJywgJycpO1xuICAgIC8qKlxuICAgICAqIGZvciBzY2llbnRpZmljIG5vdGF0aW9uIHRoZSBjdXJyZW50IGRlY2ltYWwgaW5kZXggd2lsbCBiZSBhZnRlciBmaXJzdCBudW1iZXIgKGluZGV4IDApXG4gICAgICogU28gZWZmZWN0aXZlIGRlY2ltYWwgaW5kZXggd2lsbCBhbHdheXMgYmUgMSArIGV4cG9uZW50IHZhbHVlXG4gICAgICovXG4gICAgdmFyIGRlY2ltYWxJbmRleCA9IDEgKyBleHBvbmVudDtcbiAgICB2YXIgY29mZmllY2llbnRMbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgICBpZiAoZGVjaW1hbEluZGV4IDwgMCkge1xuICAgICAgICAvLyBpZiBkZWNpbWFsIGluZGV4IGlzIGxlc3MgdGhlbiAwIGFkZCBwcmVjZWRpbmcgMHNcbiAgICAgICAgLy8gYWRkIDEgYXMgam9pbiB3aWxsIGhhdmVcbiAgICAgICAgY29lZmZpY2llbnQgPSAnMC4nICsgcmVwZWF0KCcwJywgTWF0aC5hYnMoZGVjaW1hbEluZGV4KSkgKyBjb2VmZmljaWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVjaW1hbEluZGV4ID49IGNvZmZpZWNpZW50TG4pIHtcbiAgICAgICAgLy8gaWYgZGVjaW1hbCBpbmRleCBpcyBsZXNzIHRoZW4gMCBhZGQgbGVhZGluZyAwc1xuICAgICAgICBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50ICsgcmVwZWF0KCcwJywgZGVjaW1hbEluZGV4IC0gY29mZmllY2llbnRMbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBlbHNlIGFkZCBkZWNpbWFsIHBvaW50IGF0IHByb3BlciBpbmRleFxuICAgICAgICBjb2VmZmljaWVudCA9XG4gICAgICAgICAgICAoY29lZmZpY2llbnQuc3Vic3RyaW5nKDAsIGRlY2ltYWxJbmRleCkgfHwgJzAnKSArICcuJyArIGNvZWZmaWNpZW50LnN1YnN0cmluZyhkZWNpbWFsSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbiArIGNvZWZmaWNpZW50O1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB0byByb3VuZCBwcm9wIHZhbHVlIHRvIGdpdmVuIHNjYWxlLlxuICogTm90IHVzZWQgLnJvdW5kIG9yIC5maXhlZFRvIGJlY2F1c2UgdGhhdCB3aWxsIGJyZWFrIHdpdGggYmlnIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcm91bmRUb1ByZWNpc2lvbihudW1TdHIsIHNjYWxlLCBmaXhlZERlY2ltYWxTY2FsZSkge1xuICAgIC8vaWYgbnVtYmVyIGlzIGVtcHR5IGRvbid0IGRvIGFueXRoaW5nIHJldHVybiBlbXB0eSBzdHJpbmdcbiAgICBpZiAoWycnLCAnLSddLmluZGV4T2YobnVtU3RyKSAhPT0gLTEpXG4gICAgICAgIHsgcmV0dXJuIG51bVN0cjsgfVxuICAgIHZhciBzaG91bGRIYXZlRGVjaW1hbFNlcGFyYXRvciA9IChudW1TdHIuaW5kZXhPZignLicpICE9PSAtMSB8fCBmaXhlZERlY2ltYWxTY2FsZSkgJiYgc2NhbGU7XG4gICAgdmFyIHJlZiA9IHNwbGl0RGVjaW1hbChudW1TdHIpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcmVmLmJlZm9yZURlY2ltYWw7XG4gICAgdmFyIGFmdGVyRGVjaW1hbCA9IHJlZi5hZnRlckRlY2ltYWw7XG4gICAgdmFyIGhhc05lZ2F0aW9uID0gcmVmLmhhc05lZ2F0aW9uO1xuICAgIHZhciBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdCgoXCIwLlwiICsgKGFmdGVyRGVjaW1hbCB8fCAnMCcpKSk7XG4gICAgdmFyIGZsb2F0VmFsdWVTdHIgPSBhZnRlckRlY2ltYWwubGVuZ3RoIDw9IHNjYWxlID8gKFwiMC5cIiArIGFmdGVyRGVjaW1hbCkgOiBmbG9hdFZhbHVlLnRvRml4ZWQoc2NhbGUpO1xuICAgIHZhciByb3VuZGVkRGVjaW1hbFBhcnRzID0gZmxvYXRWYWx1ZVN0ci5zcGxpdCgnLicpO1xuICAgIHZhciBpbnRQYXJ0ID0gYmVmb3JlRGVjaW1hbDtcbiAgICAvLyBpZiB3ZSBoYXZlIGNhcnkgb3ZlciBmcm9tIHJvdW5kaW5nIGRlY2ltYWwgcGFydCwgYWRkIHRoYXQgb24gYmVmb3JlIGRlY2ltYWxcbiAgICBpZiAoYmVmb3JlRGVjaW1hbCAmJiBOdW1iZXIocm91bmRlZERlY2ltYWxQYXJ0c1swXSkpIHtcbiAgICAgICAgaW50UGFydCA9IGJlZm9yZURlY2ltYWxcbiAgICAgICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHJvdW5kZWRTdHIsIGN1cnJlbnQsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHJvdW5kZWRTdHIubGVuZ3RoID4gaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoTnVtYmVyKHJvdW5kZWRTdHJbMF0pICsgTnVtYmVyKGN1cnJlbnQpKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgcm91bmRlZFN0ci5zdWJzdHJpbmcoMSwgcm91bmRlZFN0ci5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50ICsgcm91bmRlZFN0cjtcbiAgICAgICAgfSwgcm91bmRlZERlY2ltYWxQYXJ0c1swXSk7XG4gICAgfVxuICAgIHZhciBkZWNpbWFsUGFydCA9IGxpbWl0VG9TY2FsZShyb3VuZGVkRGVjaW1hbFBhcnRzWzFdIHx8ICcnLCBzY2FsZSwgZml4ZWREZWNpbWFsU2NhbGUpO1xuICAgIHZhciBuZWdhdGlvbiA9IGhhc05lZ2F0aW9uID8gJy0nIDogJyc7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBzaG91bGRIYXZlRGVjaW1hbFNlcGFyYXRvciA/ICcuJyA6ICcnO1xuICAgIHJldHVybiAoXCJcIiArIG5lZ2F0aW9uICsgaW50UGFydCArIGRlY2ltYWxTZXBhcmF0b3IgKyBkZWNpbWFsUGFydCk7XG59XG4vKiogc2V0IHRoZSBjYXJldCBwb3NpdG9uIGluIGFuIGlucHV0IGZpZWxkICoqL1xuZnVuY3Rpb24gc2V0Q2FyZXRQb3NpdGlvbihlbCwgY2FyZXRQb3MpIHtcbiAgICBlbC52YWx1ZSA9IGVsLnZhbHVlO1xuICAgIC8vIF4gdGhpcyBpcyB1c2VkIHRvIG5vdCBvbmx5IGdldCAnZm9jdXMnLCBidXRcbiAgICAvLyB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBpdCBldmVyeXRoaW5nIC1zZWxlY3RlZC1cbiAgICAvLyAoaXQgY2F1c2VzIGFuIGlzc3VlIGluIGNocm9tZSwgYW5kIGhhdmluZyBpdCBkb2Vzbid0IGh1cnQgYW55IG90aGVyIGJyb3dzZXIpXG4gICAgaWYgKGVsICE9PSBudWxsKSB7XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgaWYgKGVsLmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZWwuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlKCdjaGFyYWN0ZXInLCBjYXJldFBvcyk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIChlbC5zZWxlY3Rpb25TdGFydCA9PT0gMCBhZGRlZCBmb3IgRmlyZWZveCBidWcpXG4gICAgICAgIGlmIChlbC5zZWxlY3Rpb25TdGFydCB8fCBlbC5zZWxlY3Rpb25TdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIGVsLnNldFNlbGVjdGlvblJhbmdlKGNhcmV0UG9zLCBjYXJldFBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWlsIGNpdHksIGZvcnR1bmF0ZWx5IHRoaXMgbmV2ZXIgaGFwcGVucyAoYXMgZmFyIGFzIEkndmUgdGVzdGVkKSA6KVxuICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIGZpbmRDaGFuZ2VSYW5nZSA9IG1lbW9pemVPbmNlKGZ1bmN0aW9uIChwcmV2VmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgcHJldkxlbmd0aCA9IHByZXZWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIG5ld0xlbmd0aCA9IG5ld1ZhbHVlLmxlbmd0aDtcbiAgICB3aGlsZSAocHJldlZhbHVlW2ldID09PSBuZXdWYWx1ZVtpXSAmJiBpIDwgcHJldkxlbmd0aClcbiAgICAgICAgeyBpKys7IH1cbiAgICAvL2NoZWNrIHdoYXQgaGFzIGJlZW4gY2hhbmdlZCBmcm9tIGxhc3RcbiAgICB3aGlsZSAocHJldlZhbHVlW3ByZXZMZW5ndGggLSAxIC0gal0gPT09IG5ld1ZhbHVlW25ld0xlbmd0aCAtIDEgLSBqXSAmJlxuICAgICAgICBuZXdMZW5ndGggLSBqID4gaSAmJlxuICAgICAgICBwcmV2TGVuZ3RoIC0gaiA+IGkpIHtcbiAgICAgICAgaisrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiB7IHN0YXJ0OiBpLCBlbmQ6IHByZXZMZW5ndGggLSBqIH0sXG4gICAgICAgIHRvOiB7IHN0YXJ0OiBpLCBlbmQ6IG5ld0xlbmd0aCAtIGogfSxcbiAgICB9O1xufSk7XG4vKlxuICBSZXR1cm5zIGEgbnVtYmVyIHdob3NlIHZhbHVlIGlzIGxpbWl0ZWQgdG8gdGhlIGdpdmVuIHJhbmdlXG4qL1xuZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW0sIG1pbiksIG1heCk7XG59XG5mdW5jdGlvbiBnZUlucHV0Q2FyZXRQb3NpdGlvbihlbCkge1xuICAgIC8qTWF4IG9mIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgaXMgdGFrZW4gZm9yIHRoZSBwYXRjaCBvZiBwaXhlbCBhbmQgb3RoZXIgbW9iaWxlIGRldmljZSBjYXJldCBidWcqL1xuICAgIHJldHVybiBNYXRoLm1heChlbC5zZWxlY3Rpb25TdGFydCwgZWwuc2VsZWN0aW9uRW5kKTtcbn1cbmZ1bmN0aW9uIGFkZElucHV0TW9kZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICEobmF2aWdhdG9yLnBsYXRmb3JtICYmIC9pUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pKSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q2hhbmdlTWV0YSh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFZhbHVlOiAnJyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TWFza0F0SW5kZXgobWFzaywgaW5kZXgpIHtcbiAgICBpZiAoIG1hc2sgPT09IHZvaWQgMCApIG1hc2sgPSAnICc7XG5cbiAgICBpZiAodHlwZW9mIG1hc2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFza1tpbmRleF0gfHwgJyAnO1xufVxuZnVuY3Rpb24gZGVmYXVsdElzQ2hhcmFjdGVyU2FtZShyZWYpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gcmVmLmN1cnJlbnRWYWx1ZTtcbiAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSByZWYuZm9ybWF0dGVkVmFsdWU7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZUluZGV4ID0gcmVmLmN1cnJlbnRWYWx1ZUluZGV4O1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZUluZGV4ID0gcmVmLmZvcm1hdHRlZFZhbHVlSW5kZXg7XG5cbiAgICByZXR1cm4gY3VycmVudFZhbHVlW2N1cnJlbnRWYWx1ZUluZGV4XSA9PT0gZm9ybWF0dGVkVmFsdWVbZm9ybWF0dGVkVmFsdWVJbmRleF07XG59XG5mdW5jdGlvbiBnZXRDYXJldFBvc2l0aW9uKG5ld0Zvcm1hdHRlZFZhbHVlLCBsYXN0Rm9ybWF0dGVkVmFsdWUsIGN1clZhbHVlLCBjdXJDYXJldFBvcywgYm91bmRhcnksIGlzVmFsaWRJbnB1dENoYXJhY3RlciwgXG4vKipcbiAqIGZvcm1hdCBmdW5jdGlvbiBjYW4gY2hhbmdlIHRoZSBjaGFyYWN0ZXIsIHRoZSBjYXJldCBlbmdpbmUgcmVsaWVzIG9uIG1hcHBpbmcgb2xkIHZhbHVlIGFuZCBuZXcgdmFsdWVcbiAqIEluIHN1Y2ggY2FzZSBpZiBjaGFyYWN0ZXIgaXMgY2hhbmdlZCwgcGFyZW50IGNhbiB0ZWxsIHdoaWNoIGNoYXJzIGFyZSBlcXVpdmFsZW50XG4gKiBTb21lIGV4YW1wbGUsIGFsbCBhbGxvd2VkRGVjaW1hbENoYXJhY3RlcnMgYXJlIHVwZGF0ZWQgdG8gZGVjaW1hbENoYXJhY3RlcnMsIDJuZCBjYXNlIGlmIHVzZXIgaXMgY292ZXJ0aW5nXG4gKiBudW1iZXIgdG8gZGlmZmVyZW50IG51bWVyaWMgc3lzdGVtLlxuICovXG5pc0NoYXJhY3RlclNhbWUpIHtcbiAgICBpZiAoIGlzQ2hhcmFjdGVyU2FtZSA9PT0gdm9pZCAwICkgaXNDaGFyYWN0ZXJTYW1lID0gZGVmYXVsdElzQ2hhcmFjdGVyU2FtZTtcblxuICAgIC8qKlxuICAgICAqIGlmIHNvbWV0aGluZyBnb3QgaW5zZXJ0ZWQgb24gZW1wdHkgdmFsdWUsIGFkZCB0aGUgZm9ybWF0dGVkIGNoYXJhY3RlciBiZWZvcmUgdGhlIGN1cnJlbnQgdmFsdWUsXG4gICAgICogVGhpcyBpcyB0byBhdm9pZCB0aGUgY2FzZSB3aGVyZSB0eXBlZCBjaGFyYWN0ZXIgaXMgcHJlc2VudCBvbiBmb3JtYXQgY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIHZhciBmaXJzdEFsbG93ZWRQb3NpdGlvbiA9IGJvdW5kYXJ5LmZpbmRJbmRleChmdW5jdGlvbiAoYikgeyByZXR1cm4gYjsgfSk7XG4gICAgdmFyIHByZWZpeEZvcm1hdCA9IG5ld0Zvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIGZpcnN0QWxsb3dlZFBvc2l0aW9uKTtcbiAgICBpZiAoIWxhc3RGb3JtYXR0ZWRWYWx1ZSAmJiAhY3VyVmFsdWUuc3RhcnRzV2l0aChwcmVmaXhGb3JtYXQpKSB7XG4gICAgICAgIGxhc3RGb3JtYXR0ZWRWYWx1ZSA9IHByZWZpeEZvcm1hdDtcbiAgICAgICAgY3VyVmFsdWUgPSBwcmVmaXhGb3JtYXQgKyBjdXJWYWx1ZTtcbiAgICAgICAgY3VyQ2FyZXRQb3MgPSBjdXJDYXJldFBvcyArIHByZWZpeEZvcm1hdC5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBjdXJWYWxMbiA9IGN1clZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZm9ybWF0dGVkVmFsdWVMbiA9IG5ld0Zvcm1hdHRlZFZhbHVlLmxlbmd0aDtcbiAgICAvLyBjcmVhdGUgaW5kZXggbWFwXG4gICAgdmFyIGFkZGVkSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgaW5kZXhNYXAgPSBuZXcgQXJyYXkoY3VyVmFsTG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyVmFsTG47IGkrKykge1xuICAgICAgICBpbmRleE1hcFtpXSA9IC0xO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgakxuID0gZm9ybWF0dGVkVmFsdWVMbjsgaiA8IGpMbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaXNDaGFyU2FtZSA9IGlzQ2hhcmFjdGVyU2FtZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBjdXJWYWx1ZSxcbiAgICAgICAgICAgICAgICBsYXN0VmFsdWU6IGxhc3RGb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogbmV3Rm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlSW5kZXg6IGksXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVJbmRleDogaixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzQ2hhclNhbWUgJiYgYWRkZWRJbmRleE1hcFtqXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2ldID0gajtcbiAgICAgICAgICAgICAgICBhZGRlZEluZGV4TWFwW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgY3VycmVudCBjYXJldCBwb3NpdGlvbiBmaW5kIGNsb3Nlc3QgY2hhcmFjdGVycyAobGVmdCBhbmQgcmlnaHQgc2lkZSlcbiAgICAgKiB3aGljaCBhcmUgcHJvcGVybHkgbWFwcGVkIHRvIGZvcm1hdHRlZCB2YWx1ZS5cbiAgICAgKiBUaGUgaWRlYSBpcyB0aGF0IHRoZSBuZXcgY2FyZXQgcG9zaXRpb24gd2lsbCBleGlzdCBhbHdheXMgaW4gdGhlIGJvdW5kYXJ5IG9mXG4gICAgICogdGhhdCBtYXBwZWQgaW5kZXhcbiAgICAgKi9cbiAgICB2YXIgcG9zID0gY3VyQ2FyZXRQb3M7XG4gICAgd2hpbGUgKHBvcyA8IGN1clZhbExuICYmIChpbmRleE1hcFtwb3NdID09PSAtMSB8fCAhaXNWYWxpZElucHV0Q2hhcmFjdGVyKGN1clZhbHVlW3Bvc10pKSkge1xuICAgICAgICBwb3MrKztcbiAgICB9XG4gICAgLy8gaWYgdGhlIGNhcmV0IHBvc2l0aW9uIGlzIG9uIGxhc3Qga2VlcCB0aGUgZW5kSW5kZXggYXMgbGFzdCBmb3IgZm9ybWF0dGVkIHZhbHVlXG4gICAgdmFyIGVuZEluZGV4ID0gcG9zID09PSBjdXJWYWxMbiB8fCBpbmRleE1hcFtwb3NdID09PSAtMSA/IGZvcm1hdHRlZFZhbHVlTG4gOiBpbmRleE1hcFtwb3NdO1xuICAgIHBvcyA9IGN1ckNhcmV0UG9zIC0gMTtcbiAgICB3aGlsZSAocG9zID4gMCAmJiBpbmRleE1hcFtwb3NdID09PSAtMSlcbiAgICAgICAgeyBwb3MtLTsgfVxuICAgIHZhciBzdGFydEluZGV4ID0gcG9zID09PSAtMSB8fCBpbmRleE1hcFtwb3NdID09PSAtMSA/IDAgOiBpbmRleE1hcFtwb3NdICsgMTtcbiAgICAvKipcbiAgICAgKiBjYXNlIHdoZXJlIGEgY2hhciBpcyBhZGRlZCBvbiBzdWZmaXggYW5kIHJlbW92ZWQgZnJvbSBtaWRkbGUsIGV4YW1wbGUgMnNxMzQ1IGJlY29taW5nICQyLDM0NSBzcVxuICAgICAqIHRoZXJlIGlzIHN0aWxsIGEgbWFwcGluZyBidXQgdGhlIG9yZGVyIG9mIHN0YXJ0IGluZGV4IGFuZCBlbmQgaW5kZXggaXMgY2hhbmdlZFxuICAgICAqL1xuICAgIGlmIChzdGFydEluZGV4ID4gZW5kSW5kZXgpXG4gICAgICAgIHsgcmV0dXJuIGVuZEluZGV4OyB9XG4gICAgLyoqXG4gICAgICogZ2l2ZW4gdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaWYgaXQgY2xvc2VyIHRvIHN0YXJ0SW5kZXhcbiAgICAgKiBrZWVwIHRoZSBuZXcgY2FyZXQgcG9zaXRpb24gb24gc3RhcnQgaW5kZXggb3Iga2VlcCBpdCBjbG9zZXIgdG8gZW5kSW5kZXhcbiAgICAgKi9cbiAgICByZXR1cm4gY3VyQ2FyZXRQb3MgLSBzdGFydEluZGV4IDwgZW5kSW5kZXggLSBjdXJDYXJldFBvcyA/IHN0YXJ0SW5kZXggOiBlbmRJbmRleDtcbn1cbi8qIFRoaXMga2VlcHMgdGhlIGNhcmV0IHdpdGhpbiB0eXBpbmcgYXJlYSBzbyBwZW9wbGUgY2FuJ3QgdHlwZSBpbiBiZXR3ZWVuIHByZWZpeCBvciBzdWZmaXggb3IgZm9ybWF0IGNoYXJhY3RlcnMgKi9cbmZ1bmN0aW9uIGdldENhcmV0UG9zSW5Cb3VuZGFyeSh2YWx1ZSwgY2FyZXRQb3MsIGJvdW5kYXJ5LCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgdmFsTG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgLy8gY2xhbXAgY2FyZXQgcG9zaXRpb24gdG8gWzAsIHZhbHVlLmxlbmd0aF1cbiAgICBjYXJldFBvcyA9IGNsYW1wKGNhcmV0UG9zLCAwLCB2YWxMbik7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHdoaWxlIChjYXJldFBvcyA+PSAwICYmICFib3VuZGFyeVtjYXJldFBvc10pXG4gICAgICAgICAgICB7IGNhcmV0UG9zLS07IH1cbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgZmluZCBhbnkgc3VpdGFibGUgY2FyZXQgcG9zaXRpb24gb24gbGVmdCwgc2V0IGl0IG9uIGZpcnN0IGFsbG93ZWQgcG9zaXRpb25cbiAgICAgICAgaWYgKGNhcmV0UG9zID09PSAtMSlcbiAgICAgICAgICAgIHsgY2FyZXRQb3MgPSBib3VuZGFyeS5pbmRleE9mKHRydWUpOyB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoY2FyZXRQb3MgPD0gdmFsTG4gJiYgIWJvdW5kYXJ5W2NhcmV0UG9zXSlcbiAgICAgICAgICAgIHsgY2FyZXRQb3MrKzsgfVxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBmaW5kIGFueSBzdWl0YWJsZSBjYXJldCBwb3NpdGlvbiBvbiByaWdodCwgc2V0IGl0IG9uIGxhc3QgYWxsb3dlZCBwb3NpdGlvblxuICAgICAgICBpZiAoY2FyZXRQb3MgPiB2YWxMbilcbiAgICAgICAgICAgIHsgY2FyZXRQb3MgPSBib3VuZGFyeS5sYXN0SW5kZXhPZih0cnVlKTsgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBkb24ndCBmaW5kIGNhcmV0IHBvc2l0aW9uLCBzZXQgaXQgYXQgdGhlIGVuZCBvZiB2YWx1ZVxuICAgIGlmIChjYXJldFBvcyA9PT0gLTEpXG4gICAgICAgIHsgY2FyZXRQb3MgPSB2YWxMbjsgfVxuICAgIHJldHVybiBjYXJldFBvcztcbn1cbmZ1bmN0aW9uIGNhcmV0VW5rbm93bkZvcm1hdEJvdW5kYXJ5KGZvcm1hdHRlZFZhbHVlKSB7XG4gICAgdmFyIGJvdW5kYXJ5QXJ5ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZm9ybWF0dGVkVmFsdWUubGVuZ3RoICsgMSB9KS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxuID0gYm91bmRhcnlBcnkubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICAvLyBjb25zaWRlciBjYXJldCB0byBiZSBpbiBib3VuZGFyeSBpZiBpdCBpcyBiZWZvcmUgb3IgYWZ0ZXIgbnVtZXJpYyB2YWx1ZVxuICAgICAgICBib3VuZGFyeUFyeVtpXSA9IEJvb2xlYW4oY2hhcklzTnVtYmVyKGZvcm1hdHRlZFZhbHVlW2ldKSB8fCBjaGFySXNOdW1iZXIoZm9ybWF0dGVkVmFsdWVbaSAtIDFdKSk7XG4gICAgfVxuICAgIHJldHVybiBib3VuZGFyeUFyeTtcbn1cbmZ1bmN0aW9uIHVzZUludGVybmFsVmFsdWVzKHZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlSXNOdW1lcmljU3RyaW5nLCBmb3JtYXQsIHJlbW92ZUZvcm1hdHRpbmcsIG9uVmFsdWVDaGFuZ2UpIHtcbiAgICBpZiAoIG9uVmFsdWVDaGFuZ2UgPT09IHZvaWQgMCApIG9uVmFsdWVDaGFuZ2UgPSBub29wO1xuXG4gICAgdmFyIGdldFZhbHVlcyA9IHVzZVBlcnNpc3RlbnRDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUsIHZhbHVlSXNOdW1lcmljU3RyaW5nKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSwgbnVtQXNTdHJpbmc7XG4gICAgICAgIGlmIChpc05vdFZhbGlkVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBudW1Bc1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlSXNOdW1lcmljU3RyaW5nKSB7XG4gICAgICAgICAgICBudW1Bc1N0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB0b051bWVyaWNTdHJpbmcodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdChudW1Bc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcodmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdChudW1Bc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZzogbnVtQXNTdHJpbmcgfTtcbiAgICB9KTtcbiAgICB2YXIgcmVmID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWVzKGlzTmlsKHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlLCB2YWx1ZUlzTnVtZXJpY1N0cmluZyk7XG4gICAgfSk7XG4gICAgdmFyIHZhbHVlcyA9IHJlZlswXTtcbiAgICB2YXIgc2V0VmFsdWVzID0gcmVmWzFdO1xuICAgIHZhciBfb25WYWx1ZUNoYW5nZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZXMsIHNvdXJjZUluZm8pIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlcy5mb3JtYXR0ZWRWYWx1ZSAhPT0gdmFsdWVzLmZvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZXMoe1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBuZXdWYWx1ZXMuZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgbnVtQXNTdHJpbmc6IG5ld1ZhbHVlcy52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGwgcGFyZW50IG9uIHZhbHVlIGNoYW5nZSBpZiBvbmx5IGlmIGZvcm1hdHRlZCB2YWx1ZSBpcyBjaGFuZ2VkXG4gICAgICAgIG9uVmFsdWVDaGFuZ2UobmV3VmFsdWVzLCBzb3VyY2VJbmZvKTtcbiAgICB9O1xuICAgIC8vIGlmIHZhbHVlIGlzIHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkLCB1c2UgdGhlIGludGVybmFsIHN0YXRlJ3MgdmFsdWUgdG8gZm9ybWF0IHdpdGggbmV3IHByb3BzXG4gICAgdmFyIF92YWx1ZSA9IHZhbHVlO1xuICAgIHZhciBfdmFsdWVJc051bWVyaWNTdHJpbmcgPSB2YWx1ZUlzTnVtZXJpY1N0cmluZztcbiAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICAgIF92YWx1ZSA9IHZhbHVlcy5udW1Bc1N0cmluZztcbiAgICAgICAgX3ZhbHVlSXNOdW1lcmljU3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG5ld1ZhbHVlcyA9IGdldFZhbHVlcyhfdmFsdWUsIF92YWx1ZUlzTnVtZXJpY1N0cmluZyk7XG4gICAgdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFZhbHVlcyhuZXdWYWx1ZXMpO1xuICAgIH0sIFtuZXdWYWx1ZXMuZm9ybWF0dGVkVmFsdWVdKTtcbiAgICByZXR1cm4gW3ZhbHVlcywgX29uVmFsdWVDaGFuZ2VdO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVtb3ZlRm9ybWF0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXjAtOV0vZywgJycpO1xufVxuZnVuY3Rpb24gZGVmYXVsdEZvcm1hdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIE51bWJlckZvcm1hdEJhc2UocHJvcHMpIHtcbiAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7IGlmICggdHlwZSA9PT0gdm9pZCAwICkgdHlwZSA9ICd0ZXh0JztcbiAgICB2YXIgZGlzcGxheVR5cGUgPSBwcm9wcy5kaXNwbGF5VHlwZTsgaWYgKCBkaXNwbGF5VHlwZSA9PT0gdm9pZCAwICkgZGlzcGxheVR5cGUgPSAnaW5wdXQnO1xuICAgIHZhciBjdXN0b21JbnB1dCA9IHByb3BzLmN1c3RvbUlucHV0O1xuICAgIHZhciByZW5kZXJUZXh0ID0gcHJvcHMucmVuZGVyVGV4dDtcbiAgICB2YXIgZ2V0SW5wdXRSZWYgPSBwcm9wcy5nZXRJbnB1dFJlZjtcbiAgICB2YXIgZm9ybWF0ID0gcHJvcHMuZm9ybWF0OyBpZiAoIGZvcm1hdCA9PT0gdm9pZCAwICkgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdDtcbiAgICB2YXIgcmVtb3ZlRm9ybWF0dGluZyA9IHByb3BzLnJlbW92ZUZvcm1hdHRpbmc7IGlmICggcmVtb3ZlRm9ybWF0dGluZyA9PT0gdm9pZCAwICkgcmVtb3ZlRm9ybWF0dGluZyA9IGRlZmF1bHRSZW1vdmVGb3JtYXR0aW5nO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgdmFyIHZhbHVlSXNOdW1lcmljU3RyaW5nID0gcHJvcHMudmFsdWVJc051bWVyaWNTdHJpbmc7XG4gICAgdmFyIG9uVmFsdWVDaGFuZ2UgPSBwcm9wcy5vblZhbHVlQ2hhbmdlO1xuICAgIHZhciBpc0FsbG93ZWQgPSBwcm9wcy5pc0FsbG93ZWQ7XG4gICAgdmFyIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2U7IGlmICggb25DaGFuZ2UgPT09IHZvaWQgMCApIG9uQ2hhbmdlID0gbm9vcDtcbiAgICB2YXIgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duOyBpZiAoIG9uS2V5RG93biA9PT0gdm9pZCAwICkgb25LZXlEb3duID0gbm9vcDtcbiAgICB2YXIgb25Nb3VzZVVwID0gcHJvcHMub25Nb3VzZVVwOyBpZiAoIG9uTW91c2VVcCA9PT0gdm9pZCAwICkgb25Nb3VzZVVwID0gbm9vcDtcbiAgICB2YXIgb25Gb2N1cyA9IHByb3BzLm9uRm9jdXM7IGlmICggb25Gb2N1cyA9PT0gdm9pZCAwICkgb25Gb2N1cyA9IG5vb3A7XG4gICAgdmFyIG9uQmx1ciA9IHByb3BzLm9uQmx1cjsgaWYgKCBvbkJsdXIgPT09IHZvaWQgMCApIG9uQmx1ciA9IG5vb3A7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIHZhciBnZXRDYXJldEJvdW5kYXJ5ID0gcHJvcHMuZ2V0Q2FyZXRCb3VuZGFyeTsgaWYgKCBnZXRDYXJldEJvdW5kYXJ5ID09PSB2b2lkIDAgKSBnZXRDYXJldEJvdW5kYXJ5ID0gY2FyZXRVbmtub3duRm9ybWF0Qm91bmRhcnk7XG4gICAgdmFyIGlzVmFsaWRJbnB1dENoYXJhY3RlciA9IHByb3BzLmlzVmFsaWRJbnB1dENoYXJhY3RlcjsgaWYgKCBpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIgPT09IHZvaWQgMCApIGlzVmFsaWRJbnB1dENoYXJhY3RlciA9IGNoYXJJc051bWJlcjtcbiAgICB2YXIgaXNDaGFyYWN0ZXJTYW1lID0gcHJvcHMuaXNDaGFyYWN0ZXJTYW1lO1xuICAgIHZhciBvdGhlclByb3BzID0gX19yZXN0KHByb3BzLCBbXCJ0eXBlXCIsIFwiZGlzcGxheVR5cGVcIiwgXCJjdXN0b21JbnB1dFwiLCBcInJlbmRlclRleHRcIiwgXCJnZXRJbnB1dFJlZlwiLCBcImZvcm1hdFwiLCBcInJlbW92ZUZvcm1hdHRpbmdcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJ2YWx1ZUlzTnVtZXJpY1N0cmluZ1wiLCBcIm9uVmFsdWVDaGFuZ2VcIiwgXCJpc0FsbG93ZWRcIiwgXCJvbkNoYW5nZVwiLCBcIm9uS2V5RG93blwiLCBcIm9uTW91c2VVcFwiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJ2YWx1ZVwiLCBcImdldENhcmV0Qm91bmRhcnlcIiwgXCJpc1ZhbGlkSW5wdXRDaGFyYWN0ZXJcIiwgXCJpc0NoYXJhY3RlclNhbWVcIl0pO1xuICAgIHZhciByZWYgPSB1c2VJbnRlcm5hbFZhbHVlcyhwcm9wVmFsdWUsIGRlZmF1bHRWYWx1ZSwgQm9vbGVhbih2YWx1ZUlzTnVtZXJpY1N0cmluZyksIGZvcm1hdCwgcmVtb3ZlRm9ybWF0dGluZywgb25WYWx1ZUNoYW5nZSk7XG4gICAgdmFyIHJlZl8wID0gcmVmWzBdO1xuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHJlZl8wLmZvcm1hdHRlZFZhbHVlO1xuICAgIHZhciBudW1Bc1N0cmluZyA9IHJlZl8wLm51bUFzU3RyaW5nO1xuICAgIHZhciBvbkZvcm1hdHRlZFZhbHVlQ2hhbmdlID0gcmVmWzFdO1xuICAgIHZhciBsYXN0VXBkYXRlZFZhbHVlID0gdXNlUmVmKHsgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZzogbnVtQXNTdHJpbmcgfSk7XG4gICAgdmFyIF9vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlcywgc291cmNlKSB7XG4gICAgICAgIGxhc3RVcGRhdGVkVmFsdWUuY3VycmVudCA9IHsgZm9ybWF0dGVkVmFsdWU6IHZhbHVlcy5mb3JtYXR0ZWRWYWx1ZSwgbnVtQXNTdHJpbmc6IHZhbHVlcy52YWx1ZSB9O1xuICAgICAgICBvbkZvcm1hdHRlZFZhbHVlQ2hhbmdlKHZhbHVlcywgc291cmNlKTtcbiAgICB9O1xuICAgIHZhciByZWYkMSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB2YXIgbW91bnRlZCA9IHJlZiQxWzBdO1xuICAgIHZhciBzZXRNb3VudGVkID0gcmVmJDFbMV07XG4gICAgdmFyIGZvY3VzZWRFbG0gPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIHRpbWVvdXQgPSB1c2VSZWYoe1xuICAgICAgICBzZXRDYXJldFRpbWVvdXQ6IG51bGwsXG4gICAgICAgIGZvY3VzVGltZW91dDogbnVsbCxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudC5zZXRDYXJldFRpbWVvdXQpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudC5mb2N1c1RpbWVvdXQpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgX2Zvcm1hdCA9IGZvcm1hdDtcbiAgICB2YXIgZ2V0VmFsdWVPYmplY3QgPSBmdW5jdGlvbiAoZm9ybWF0dGVkVmFsdWUsIG51bUFzU3RyaW5nKSB7XG4gICAgICAgIHZhciBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChudW1Bc1N0cmluZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVtQXNTdHJpbmcsXG4gICAgICAgICAgICBmbG9hdFZhbHVlOiBpc05hTihmbG9hdFZhbHVlKSA/IHVuZGVmaW5lZCA6IGZsb2F0VmFsdWUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAoZWwsIGNhcmV0UG9zLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgLy8gZG9uJ3QgcmVzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIHdoZW4gdGhlIHdob2xlIGlucHV0IGNvbnRlbnQgaXMgc2VsZWN0ZWRcbiAgICAgICAgaWYgKGVsLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIGVsLnNlbGVjdGlvbkVuZCA9PT0gZWwudmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgeyByZXR1cm47IH1cbiAgICAgICAgLyogc2V0dGluZyBjYXJldCBwb3NpdGlvbiB3aXRoaW4gdGltZW91dCBvZiAwbXMgaXMgcmVxdWlyZWQgZm9yIG1vYmlsZSBjaHJvbWUsXG4gICAgICAgIG90aGVyd2lzZSBicm93c2VyIHJlc2V0cyB0aGUgY2FyZXQgcG9zaXRpb24gYWZ0ZXIgd2Ugc2V0IGl0XG4gICAgICAgIFdlIGFyZSBhbHNvIHNldHRpbmcgaXQgd2l0aG91dCB0aW1lb3V0IHNvIHRoYXQgaW4gbm9ybWFsIGJyb3dzZXIgd2UgZG9uJ3Qgc2VlIHRoZSBmbGlja2VyaW5nICovXG4gICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zKTtcbiAgICAgICAgdGltZW91dC5jdXJyZW50LnNldENhcmV0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVsLnZhbHVlID09PSBjdXJyZW50VmFsdWUgJiYgZWwuc2VsZWN0aW9uU3RhcnQgIT09IGNhcmV0UG9zKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgY2FyZXRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIC8qIFRoaXMga2VlcHMgdGhlIGNhcmV0IHdpdGhpbiB0eXBpbmcgYXJlYSBzbyBwZW9wbGUgY2FuJ3QgdHlwZSBpbiBiZXR3ZWVuIHByZWZpeCBvciBzdWZmaXggKi9cbiAgICB2YXIgY29ycmVjdENhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIGNhcmV0UG9zLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGdldENhcmV0UG9zSW5Cb3VuZGFyeSh2YWx1ZSwgY2FyZXRQb3MsIGdldENhcmV0Qm91bmRhcnkodmFsdWUpLCBkaXJlY3Rpb24pO1xuICAgIH07XG4gICAgdmFyIGdldE5ld0NhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSwgbmV3Rm9ybWF0dGVkVmFsdWUsIGNhcmV0UG9zKSB7XG4gICAgICAgIHZhciBjYXJldEJvdW5kYXJ5ID0gZ2V0Q2FyZXRCb3VuZGFyeShuZXdGb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FyZXRQb3MgPSBnZXRDYXJldFBvc2l0aW9uKG5ld0Zvcm1hdHRlZFZhbHVlLCBmb3JtYXR0ZWRWYWx1ZSwgaW5wdXRWYWx1ZSwgY2FyZXRQb3MsIGNhcmV0Qm91bmRhcnksIGlzVmFsaWRJbnB1dENoYXJhY3RlciwgaXNDaGFyYWN0ZXJTYW1lKTtcbiAgICAgICAgLy9jb3JyZWN0IGNhcmV0IHBvc2l0aW9uIGlmIGl0cyBvdXRzaWRlIG9mIGVkaXRhYmxlIGFyZWFcbiAgICAgICAgdXBkYXRlZENhcmV0UG9zID0gZ2V0Q2FyZXRQb3NJbkJvdW5kYXJ5KG5ld0Zvcm1hdHRlZFZhbHVlLCB1cGRhdGVkQ2FyZXRQb3MsIGNhcmV0Qm91bmRhcnkpO1xuICAgICAgICByZXR1cm4gdXBkYXRlZENhcmV0UG9zO1xuICAgIH07XG4gICAgdmFyIHVwZGF0ZVZhbHVlQW5kQ2FyZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIG5ld0Zvcm1hdHRlZFZhbHVlID0gcGFyYW1zLmZvcm1hdHRlZFZhbHVlOyBpZiAoIG5ld0Zvcm1hdHRlZFZhbHVlID09PSB2b2lkIDAgKSBuZXdGb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuICAgICAgICB2YXIgaW5wdXQgPSBwYXJhbXMuaW5wdXQ7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlO1xuICAgICAgICB2YXIgZXZlbnQgPSBwYXJhbXMuZXZlbnQ7XG4gICAgICAgIHZhciBudW1Bc1N0cmluZyA9IHBhcmFtcy5udW1Bc1N0cmluZztcbiAgICAgICAgdmFyIGNhcmV0UG9zO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlID0gcGFyYW1zLmlucHV0VmFsdWUgfHwgaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB2YXIgY3VycmVudENhcmV0UG9zaXRpb24gPSBnZUlucHV0Q2FyZXRQb3NpdGlvbihpbnB1dCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNldCB0aGUgdmFsdWUgaW1wZXJhdGl2ZWx5LCB0aGlzIGlzIHJlcXVpcmVkIGZvciBJRSBmaXhcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYWxzbyByZXF1aXJlZCBhcyBpZiBuZXcgY2FyZXQgcG9zaXRpb24gaXMgYmV5b25kIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgICAgICAgICAqIENhcmV0IHBvc2l0aW9uIHdpbGwgbm90IGJlIHNldCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBuZXdGb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgY2FyZXRQb3MgPSBnZXROZXdDYXJldFBvc2l0aW9uKGlucHV0VmFsdWUsIG5ld0Zvcm1hdHRlZFZhbHVlLCBjdXJyZW50Q2FyZXRQb3NpdGlvbik7XG4gICAgICAgICAgICAvL3NldCBjYXJldCBwb3NpdGlvbiBpbXBlcmF0aXZlbHlcbiAgICAgICAgICAgIGlmIChjYXJldFBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oaW5wdXQsIGNhcmV0UG9zLCBuZXdGb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0Zvcm1hdHRlZFZhbHVlICE9PSBmb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gdHJpZ2dlciBvblZhbHVlQ2hhbmdlIHN5bmNocm9ub3VzbHksIHNvIHBhcmVudCBpcyB1cGRhdGVkIGFsb25nIHdpdGggdGhlIG51bWJlciBmb3JtYXQuIEZpeCBmb3IgIzI3NywgIzI4N1xuICAgICAgICAgICAgX29uVmFsdWVDaGFuZ2UoZ2V0VmFsdWVPYmplY3QobmV3Rm9ybWF0dGVkVmFsdWUsIG51bUFzU3RyaW5nKSwgeyBldmVudDogZXZlbnQsIHNvdXJjZTogc291cmNlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBpZiB0aGUgZm9ybWF0dGVkIHZhbHVlIGlzIG5vdCBzeW5jZWQgdG8gcGFyZW50LCBvciBpZiB0aGUgZm9ybWF0dGVkIHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIGxhc3Qgc3luY2VkIHZhbHVlIHN5bmMgaXRcbiAgICAgKiB3ZSBhbHNvIGRvbid0IG5lZWQgdG8gc3luYyB0byB0aGUgcGFyZW50IGlmIG5vIGZvcm1hdHRpbmcgaXMgYXBwbGllZFxuICAgICAqIGlmIHRoZSBmb3JtYXR0aW5nIHByb3BzIGlzIHJlbW92ZWQsIGluIHdoaWNoIGNhc2UgbGFzdCBmb3JtYXR0ZWQgdmFsdWUgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgbnVtZXJpYyBzdHJpbmcgdmFsdWVcbiAgICAgKiBpbiBzdWNoIGNhc2Ugd2UgbmVlZCB0byBpbmZvcm0gdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmID0gbGFzdFVwZGF0ZWRWYWx1ZS5jdXJyZW50O1xuICAgICAgICB2YXIgbGFzdEZvcm1hdHRlZFZhbHVlID0gcmVmLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB2YXIgbGFzdE51bUFzU3RyaW5nID0gcmVmLm51bUFzU3RyaW5nO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IGxhc3RGb3JtYXR0ZWRWYWx1ZSAmJlxuICAgICAgICAgICAgKGZvcm1hdHRlZFZhbHVlICE9PSBudW1Bc1N0cmluZyB8fCBsYXN0Rm9ybWF0dGVkVmFsdWUgIT09IGxhc3ROdW1Bc1N0cmluZykpIHtcbiAgICAgICAgICAgIF9vblZhbHVlQ2hhbmdlKGdldFZhbHVlT2JqZWN0KGZvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZyksIHtcbiAgICAgICAgICAgICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogU291cmNlVHlwZS5wcm9wcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Zvcm1hdHRlZFZhbHVlLCBudW1Bc1N0cmluZ10pO1xuICAgIC8vIGFsc28gaWYgZm9ybWF0dGVkIHZhbHVlIGlzIGNoYW5nZWQgZnJvbSB0aGUgcHJvcHMsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvblxuICAgIC8vIGtlZXAgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gaWYgZWxlbWVudCBpcyBmb2N1c2VkXG4gICAgdmFyIGN1cnJlbnRDYXJldFBvc2l0aW9uID0gZm9jdXNlZEVsbS5jdXJyZW50XG4gICAgICAgID8gZ2VJbnB1dENhcmV0UG9zaXRpb24oZm9jdXNlZEVsbS5jdXJyZW50KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAvLyBuZWVkZWQgdG8gcHJldmVudCB3YXJuaW5nIHdpdGggdXNlTGF5b3V0RWZmZWN0IG9uIHNlcnZlclxuICAgIHZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGZvY3VzZWRFbG0uY3VycmVudDtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBsYXN0VXBkYXRlZFZhbHVlLmN1cnJlbnQuZm9ybWF0dGVkVmFsdWUgJiYgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBjYXJldFBvcyA9IGdldE5ld0NhcmV0UG9zaXRpb24obGFzdFVwZGF0ZWRWYWx1ZS5jdXJyZW50LmZvcm1hdHRlZFZhbHVlLCBmb3JtYXR0ZWRWYWx1ZSwgY3VycmVudENhcmV0UG9zaXRpb24pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXQgdGhlIHZhbHVlIGltcGVyYXRpdmVseSwgYXMgd2Ugc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBhcyB3ZWxsIGltcGVyYXRpdmVseS5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgdG8ga2VlcCB2YWx1ZSBhbmQgY2FyZXQgcG9zaXRpb24gaW4gc3luY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oaW5wdXQsIGNhcmV0UG9zLCBmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbZm9ybWF0dGVkVmFsdWVdKTtcbiAgICB2YXIgZm9ybWF0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlLCBldmVudCwgc291cmNlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VSYW5nZSA9IGZpbmRDaGFuZ2VSYW5nZShmb3JtYXR0ZWRWYWx1ZSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgIHZhciBjaGFuZ2VNZXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFuZ2VSYW5nZSksIHsgbGFzdFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSB9KTtcbiAgICAgICAgdmFyIF9udW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSk7XG4gICAgICAgIHZhciBfZm9ybWF0dGVkVmFsdWUgPSBfZm9ybWF0KF9udW1Bc1N0cmluZyk7XG4gICAgICAgIC8vIGZvcm1hdHRpbmcgY2FuIHJlbW92ZSBzb21lIG9mIHRoZSBudW1iZXIgY2hhcnMsIHNvIHdlIG5lZWQgdG8gZmluZSBudW1iZXIgc3RyaW5nIGFnYWluXG4gICAgICAgIF9udW1Bc1N0cmluZyA9IHJlbW92ZUZvcm1hdHRpbmcoX2Zvcm1hdHRlZFZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoaXNBbGxvd2VkICYmICFpc0FsbG93ZWQoZ2V0VmFsdWVPYmplY3QoX2Zvcm1hdHRlZFZhbHVlLCBfbnVtQXNTdHJpbmcpKSkge1xuICAgICAgICAgICAgLy9yZXNldCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2FyZXRQb3NpdGlvbiA9IGdlSW5wdXRDYXJldFBvc2l0aW9uKGlucHV0KTtcbiAgICAgICAgICAgIHZhciBjYXJldFBvcyA9IGdldE5ld0NhcmV0UG9zaXRpb24oaW5wdXRWYWx1ZSwgZm9ybWF0dGVkVmFsdWUsIGN1cnJlbnRDYXJldFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICBzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbihpbnB1dCwgY2FyZXRQb3MsIGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVWYWx1ZUFuZENhcmV0UG9zaXRpb24oe1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IF9mb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgIG51bUFzU3RyaW5nOiBfbnVtQXNTdHJpbmcsXG4gICAgICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBpbnB1dDogZXZlbnQudGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB2YXIgX29uQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBpbnB1dFZhbHVlID0gZWwudmFsdWU7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZm9ybWF0SW5wdXRWYWx1ZShpbnB1dFZhbHVlLCBlLCBTb3VyY2VUeXBlLmV2ZW50KTtcbiAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICB7IG9uQ2hhbmdlKGUpOyB9XG4gICAgfTtcbiAgICB2YXIgX29uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIga2V5ID0gZS5rZXk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gZWwuc2VsZWN0aW9uRW5kO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbC52YWx1ZTsgaWYgKCB2YWx1ZSA9PT0gdm9pZCAwICkgdmFsdWUgPSAnJztcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbjtcbiAgICAgICAgLy9IYW5kbGUgYmFja3NwYWNlIGFuZCBkZWxldGUgYWdhaW5zdCBub24gbnVtZXJpY2FsL2RlY2ltYWwgY2hhcmFjdGVycyBvciBhcnJvdyBrZXlzXG4gICAgICAgIGlmIChrZXkgPT09ICdBcnJvd0xlZnQnIHx8IGtleSA9PT0gJ0JhY2tzcGFjZScpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiA9IE1hdGgubWF4KHNlbGVjdGlvblN0YXJ0IC0gMSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnQXJyb3dSaWdodCcpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiA9IE1hdGgubWluKHNlbGVjdGlvblN0YXJ0ICsgMSwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgICBleHBlY3RlZENhcmV0UG9zaXRpb24gPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgfVxuICAgICAgICAvL2lmIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiBpcyBub3Qgc2V0IGl0IG1lYW5zIHdlIGRvbid0IHdhbnQgdG8gSGFuZGxlIGtleURvd25cbiAgICAgICAgLy8gYWxzbyBpZiBtdWx0aXBsZSBjaGFyYWN0ZXJzIGFyZSBzZWxlY3RlZCBkb24ndCBoYW5kbGVcbiAgICAgICAgaWYgKGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIG9uS2V5RG93bihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Q2FyZXRQb3NpdGlvbiA9IGV4cGVjdGVkQ2FyZXRQb3NpdGlvbjtcbiAgICAgICAgaWYgKGtleSA9PT0gJ0Fycm93TGVmdCcgfHwga2V5ID09PSAnQXJyb3dSaWdodCcpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBrZXkgPT09ICdBcnJvd0xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIG5ld0NhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgZXhwZWN0ZWRDYXJldFBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgLy8gYXJyb3cgbGVmdCBvciByaWdodCBvbmx5IG1vdmVzIHRoZSBjYXJldCwgc28gbm8gbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50LCBpZiB3ZSBhcmUgaGFuZGxpbmcgaXQgbWFudWFsbHlcbiAgICAgICAgICAgIGlmIChuZXdDYXJldFBvc2l0aW9uICE9PSBleHBlY3RlZENhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnRGVsZXRlJyAmJiAhaXNWYWxpZElucHV0Q2hhcmFjdGVyKHZhbHVlW2V4cGVjdGVkQ2FyZXRQb3NpdGlvbl0pKSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGRlbGV0ZSBnbyB0byBjbG9zZXN0IGNhcmV0IGJvdW5kYXJ5IG9uIHRoZSByaWdodCBzaWRlXG4gICAgICAgICAgICBuZXdDYXJldFBvc2l0aW9uID0gY29ycmVjdENhcmV0UG9zaXRpb24odmFsdWUsIGV4cGVjdGVkQ2FyZXRQb3NpdGlvbiwgJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyAmJiAhaXNWYWxpZElucHV0Q2hhcmFjdGVyKHZhbHVlW2V4cGVjdGVkQ2FyZXRQb3NpdGlvbl0pKSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGJhY2tzcGFjZSBnbyB0byBjbG9zZXN0IGNhcmV0IGJvdW5kYXJ5IG9uIHRoZSBsZWZ0IHNpZGVcbiAgICAgICAgICAgIG5ld0NhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgZXhwZWN0ZWRDYXJldFBvc2l0aW9uLCAnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDYXJldFBvc2l0aW9uICE9PSBleHBlY3RlZENhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHNldFBhdGNoZWRDYXJldFBvc2l0aW9uKGVsLCBuZXdDYXJldFBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogTk9URTogdGhpcyBpcyBqdXN0IHJlcXVpcmVkIGZvciB1bml0IHRlc3QgYXMgd2UgbmVlZCB0byBnZXQgdGhlIG5ld0NhcmV0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgUmVtb3ZlIHRoaXMgd2hlbiB5b3UgZmluZCBkaWZmZXJlbnQgc29sdXRpb24gKi9cbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBpZiAoZS5pc1VuaXRUZXN0UnVuKSB7XG4gICAgICAgICAgICBzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbihlbCwgbmV3Q2FyZXRQb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bihlKTtcbiAgICB9O1xuICAgIC8qKiByZXF1aXJlZCB0byBoYW5kbGUgdGhlIGNhcmV0IHBvc2l0aW9uIHdoZW4gY2xpY2sgYW55d2hlcmUgd2l0aGluIHRoZSBpbnB1dCAqKi9cbiAgICB2YXIgX29uTW91c2VVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAvKipcbiAgICAgICAgICogTk9URTogd2UgaGF2ZSB0byBnaXZlIGRlZmF1bHQgdmFsdWUgZm9yIHZhbHVlIGFzIGluIGNhc2Ugd2hlbiBjdXN0b20gaW5wdXQgaXMgcHJvdmlkZWRcbiAgICAgICAgICogdmFsdWUgY2FuIGNvbWUgYXMgdW5kZWZpbmVkIHdoZW4gbm90aGluZyBpcyBwcm92aWRlZCBvbiB2YWx1ZSBwcm9wLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBlbC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlOyBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgdmFyIGNhcmV0UG9zaXRpb24gPSBjb3JyZWN0Q2FyZXRQb3NpdGlvbih2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgaWYgKGNhcmV0UG9zaXRpb24gIT09IHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24oZWwsIGNhcmV0UG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbk1vdXNlVXAoZSk7XG4gICAgfTtcbiAgICB2YXIgX29uRm9jdXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBXb3JrYXJvdW5kIENocm9tZSBhbmQgU2FmYXJpIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NzkzMjhcbiAgICAgICAgLy8gKG9uRm9jdXMgZXZlbnQgdGFyZ2V0IHNlbGVjdGlvblN0YXJ0IGlzIGFsd2F5cyAwIGJlZm9yZSBzZXRUaW1lb3V0KVxuICAgICAgICBpZiAoZS5wZXJzaXN0KVxuICAgICAgICAgICAgeyBlLnBlcnNpc3QoKTsgfVxuICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGZvY3VzZWRFbG0uY3VycmVudCA9IGVsO1xuICAgICAgICB0aW1lb3V0LmN1cnJlbnQuZm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBlbC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbC52YWx1ZTsgaWYgKCB2YWx1ZSA9PT0gdm9pZCAwICkgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIHZhciBjYXJldFBvc2l0aW9uID0gY29ycmVjdENhcmV0UG9zaXRpb24odmFsdWUsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIC8vc2V0UGF0Y2hlZENhcmV0UG9zaXRpb24gb25seSB3aGVuIGV2ZXJ5dGhpbmcgaXMgbm90IHNlbGVjdGVkIG9uIGZvY3VzICh3aGlsZSB0YWJiaW5nIGludG8gdGhlIGZpZWxkKVxuICAgICAgICAgICAgaWYgKGNhcmV0UG9zaXRpb24gIT09IHNlbGVjdGlvblN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgIShzZWxlY3Rpb25TdGFydCA9PT0gMCAmJiBzZWxlY3Rpb25FbmQgPT09IHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbihlbCwgY2FyZXRQb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Gb2N1cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7IGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQgfSkpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIHZhciBfb25CbHVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZm9jdXNlZEVsbS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudC5mb2N1c1RpbWVvdXQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dC5jdXJyZW50LnNldENhcmV0VGltZW91dCk7XG4gICAgICAgIG9uQmx1cihlKTtcbiAgICB9O1xuICAgIC8vIGFkZCBpbnB1dCBtb2RlIG9uIGVsZW1lbnQgYmFzZWQgb24gZm9ybWF0IHByb3AgYW5kIGRldmljZSBvbmNlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZFxuICAgIHZhciBpbnB1dE1vZGUgPSBtb3VudGVkICYmIGFkZElucHV0TW9kZSgpID8gJ251bWVyaWMnIDogdW5kZWZpbmVkO1xuICAgIHZhciBpbnB1dFByb3BzID0gT2JqZWN0LmFzc2lnbih7IGlucHV0TW9kZTogaW5wdXRNb2RlIH0sIG90aGVyUHJvcHMsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWU6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICBvbkNoYW5nZTogX29uQ2hhbmdlLFxuICAgICAgICBvbktleURvd246IF9vbktleURvd24sXG4gICAgICAgIG9uTW91c2VVcDogX29uTW91c2VVcCxcbiAgICAgICAgb25Gb2N1czogX29uRm9jdXMsXG4gICAgICAgIG9uQmx1cjogX29uQmx1cixcbiAgICB9KTtcbiAgICBpZiAoZGlzcGxheVR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICByZXR1cm4gcmVuZGVyVGV4dCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXJUZXh0KGZvcm1hdHRlZFZhbHVlLCBvdGhlclByb3BzKSB8fCBudWxsKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgb3RoZXJQcm9wcywgeyByZWY6IGdldElucHV0UmVmIH0pLCBmb3JtYXR0ZWRWYWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXN0b21JbnB1dCkge1xuICAgICAgICB2YXIgQ3VzdG9tSW5wdXQgPSBjdXN0b21JbnB1dDtcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21JbnB1dCwgT2JqZWN0LmFzc2lnbih7fSwgaW5wdXRQcm9wcywgeyByZWY6IGdldElucHV0UmVmIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBPYmplY3QuYXNzaWduKHt9LCBpbnB1dFByb3BzLCB7IHJlZjogZ2V0SW5wdXRSZWYgfSkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQobnVtU3RyLCBwcm9wcykge1xuICAgIHZhciBkZWNpbWFsU2NhbGUgPSBwcm9wcy5kZWNpbWFsU2NhbGU7XG4gICAgdmFyIGZpeGVkRGVjaW1hbFNjYWxlID0gcHJvcHMuZml4ZWREZWNpbWFsU2NhbGU7XG4gICAgdmFyIHByZWZpeCA9IHByb3BzLnByZWZpeDsgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuICAgIHZhciBzdWZmaXggPSBwcm9wcy5zdWZmaXg7IGlmICggc3VmZml4ID09PSB2b2lkIDAgKSBzdWZmaXggPSAnJztcbiAgICB2YXIgYWxsb3dOZWdhdGl2ZSA9IHByb3BzLmFsbG93TmVnYXRpdmU7XG4gICAgdmFyIHRob3VzYW5kc0dyb3VwU3R5bGUgPSBwcm9wcy50aG91c2FuZHNHcm91cFN0eWxlOyBpZiAoIHRob3VzYW5kc0dyb3VwU3R5bGUgPT09IHZvaWQgMCApIHRob3VzYW5kc0dyb3VwU3R5bGUgPSAndGhvdXNhbmQnO1xuICAgIC8vIGRvbid0IGFwcGx5IGZvcm1hdHRpbmcgb24gZW1wdHkgc3RyaW5nIG9yICctJ1xuICAgIGlmIChudW1TdHIgPT09ICcnIHx8IG51bVN0ciA9PT0gJy0nKSB7XG4gICAgICAgIHJldHVybiBudW1TdHI7XG4gICAgfVxuICAgIHZhciByZWYgPSBnZXRTZXBhcmF0b3JzKHByb3BzKTtcbiAgICB2YXIgdGhvdXNhbmRTZXBhcmF0b3IgPSByZWYudGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSByZWYuZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAvKipcbiAgICAgKiBLZWVwIHRoZSBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAqIHdoZW4gZGVjaW1hbFNjYWxlIGlzIG5vdCBkZWZpbmVkIG9yIG5vbiB6ZXJvIGFuZCB0aGUgbnVtU3RyIGhhcyBkZWNpbWFsIGluIGl0XG4gICAgICogT3IgaWYgZGVjaW1hbFNjYWxlIGlzID4gMCBhbmQgZml4ZURlY2ltYWxTY2FsZSBpcyB0cnVlIChldmVuIGlmIG51bVN0ciBoYXMgbm8gZGVjaW1hbClcbiAgICAgKi9cbiAgICB2YXIgaGFzRGVjaW1hbFNlcGFyYXRvciA9IChkZWNpbWFsU2NhbGUgIT09IDAgJiYgbnVtU3RyLmluZGV4T2YoJy4nKSAhPT0gLTEpIHx8IChkZWNpbWFsU2NhbGUgJiYgZml4ZWREZWNpbWFsU2NhbGUpO1xuICAgIHZhciByZWYkMSA9IHNwbGl0RGVjaW1hbChudW1TdHIsIGFsbG93TmVnYXRpdmUpO1xuICAgIHZhciBiZWZvcmVEZWNpbWFsID0gcmVmJDEuYmVmb3JlRGVjaW1hbDtcbiAgICB2YXIgYWZ0ZXJEZWNpbWFsID0gcmVmJDEuYWZ0ZXJEZWNpbWFsO1xuICAgIHZhciBhZGROZWdhdGlvbiA9IHJlZiQxLmFkZE5lZ2F0aW9uOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuICAgIC8vYXBwbHkgZGVjaW1hbCBwcmVjaXNpb24gaWYgaXRzIGRlZmluZWRcbiAgICBpZiAoZGVjaW1hbFNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWZ0ZXJEZWNpbWFsID0gbGltaXRUb1NjYWxlKGFmdGVyRGVjaW1hbCwgZGVjaW1hbFNjYWxlLCAhIWZpeGVkRGVjaW1hbFNjYWxlKTtcbiAgICB9XG4gICAgaWYgKHRob3VzYW5kU2VwYXJhdG9yKSB7XG4gICAgICAgIGJlZm9yZURlY2ltYWwgPSBhcHBseVRob3VzYW5kU2VwYXJhdG9yKGJlZm9yZURlY2ltYWwsIHRob3VzYW5kU2VwYXJhdG9yLCB0aG91c2FuZHNHcm91cFN0eWxlKTtcbiAgICB9XG4gICAgLy9hZGQgcHJlZml4IGFuZCBzdWZmaXggd2hlbiB0aGVyZSBpcyBhIG51bWJlciBwcmVzZW50XG4gICAgaWYgKHByZWZpeClcbiAgICAgICAgeyBiZWZvcmVEZWNpbWFsID0gcHJlZml4ICsgYmVmb3JlRGVjaW1hbDsgfVxuICAgIGlmIChzdWZmaXgpXG4gICAgICAgIHsgYWZ0ZXJEZWNpbWFsID0gYWZ0ZXJEZWNpbWFsICsgc3VmZml4OyB9XG4gICAgLy9yZXN0b3JlIG5lZ2F0aW9uIHNpZ25cbiAgICBpZiAoYWRkTmVnYXRpb24pXG4gICAgICAgIHsgYmVmb3JlRGVjaW1hbCA9ICctJyArIGJlZm9yZURlY2ltYWw7IH1cbiAgICBudW1TdHIgPSBiZWZvcmVEZWNpbWFsICsgKChoYXNEZWNpbWFsU2VwYXJhdG9yICYmIGRlY2ltYWxTZXBhcmF0b3IpIHx8ICcnKSArIGFmdGVyRGVjaW1hbDtcbiAgICByZXR1cm4gbnVtU3RyO1xufVxuZnVuY3Rpb24gZ2V0U2VwYXJhdG9ycyhwcm9wcykge1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gcHJvcHMuZGVjaW1hbFNlcGFyYXRvcjsgaWYgKCBkZWNpbWFsU2VwYXJhdG9yID09PSB2b2lkIDAgKSBkZWNpbWFsU2VwYXJhdG9yID0gJy4nO1xuICAgIHZhciB0aG91c2FuZFNlcGFyYXRvciA9IHByb3BzLnRob3VzYW5kU2VwYXJhdG9yO1xuICAgIHZhciBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSBwcm9wcy5hbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM7XG4gICAgaWYgKHRob3VzYW5kU2VwYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHRob3VzYW5kU2VwYXJhdG9yID0gJywnO1xuICAgIH1cbiAgICBpZiAoIWFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycykge1xuICAgICAgICBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSBbZGVjaW1hbFNlcGFyYXRvciwgJy4nXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgdGhvdXNhbmRTZXBhcmF0b3I6IHRob3VzYW5kU2VwYXJhdG9yLFxuICAgICAgICBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnM6IGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlTmVnYXRpb24odmFsdWUsIGFsbG93TmVnYXRpdmUpIHtcbiAgICBpZiAoIHZhbHVlID09PSB2b2lkIDAgKSB2YWx1ZSA9ICcnO1xuXG4gICAgdmFyIG5lZ2F0aW9uUmVnZXggPSBuZXcgUmVnRXhwKCcoLSknKTtcbiAgICB2YXIgZG91YmxlTmVnYXRpb25SZWdleCA9IG5ldyBSZWdFeHAoJygtKSguKSooLSknKTtcbiAgICAvLyBDaGVjayBudW1iZXIgaGFzICctJyB2YWx1ZVxuICAgIHZhciBoYXNOZWdhdGlvbiA9IG5lZ2F0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG4gICAgLy8gQ2hlY2sgbnVtYmVyIGhhcyAyIG9yIG1vcmUgJy0nIHZhbHVlc1xuICAgIHZhciByZW1vdmVOZWdhdGlvbiA9IGRvdWJsZU5lZ2F0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG4gICAgLy9yZW1vdmUgbmVnYXRpb25cbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIGlmIChoYXNOZWdhdGlvbiAmJiAhcmVtb3ZlTmVnYXRpb24gJiYgYWxsb3dOZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9ICctJyArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXROdW1iZXJSZWdleChkZWNpbWFsU2VwYXJhdG9yLCBnbG9iYWwpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgoXCIoXi0pfFswLTldfFwiICsgKGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSkpLCBnbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljU3RyaW5nKHZhbCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAvLyBmb3IgZW1wdHkgdmFsdWUgd2UgY2FuIGFsd2F5cyB0cmVhdCBpdCBhcyBudW1lcmljIHN0cmluZ1xuICAgIGlmICh2YWwgPT09ICcnKVxuICAgICAgICB7IHJldHVybiB0cnVlOyB9XG4gICAgcmV0dXJuICghKHByZWZpeCA9PT0gbnVsbCB8fCBwcmVmaXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZWZpeC5tYXRjaCgvXFxkLykpICYmICEoc3VmZml4ID09PSBudWxsIHx8IHN1ZmZpeCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3VmZml4Lm1hdGNoKC9cXGQvKSkgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKE51bWJlcih2YWwpKSk7XG59XG5mdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nKHZhbHVlLCBjaGFuZ2VNZXRhLCBwcm9wcykge1xuICAgIHZhciBhc3NpZ247XG5cbiAgICBpZiAoIGNoYW5nZU1ldGEgPT09IHZvaWQgMCApIGNoYW5nZU1ldGEgPSBnZXREZWZhdWx0Q2hhbmdlTWV0YSh2YWx1ZSk7XG4gICAgdmFyIGFsbG93TmVnYXRpdmUgPSBwcm9wcy5hbGxvd05lZ2F0aXZlO1xuICAgIHZhciBwcmVmaXggPSBwcm9wcy5wcmVmaXg7IGlmICggcHJlZml4ID09PSB2b2lkIDAgKSBwcmVmaXggPSAnJztcbiAgICB2YXIgc3VmZml4ID0gcHJvcHMuc3VmZml4OyBpZiAoIHN1ZmZpeCA9PT0gdm9pZCAwICkgc3VmZml4ID0gJyc7XG4gICAgdmFyIGRlY2ltYWxTY2FsZSA9IHByb3BzLmRlY2ltYWxTY2FsZTtcbiAgICB2YXIgZnJvbSA9IGNoYW5nZU1ldGEuZnJvbTtcbiAgICB2YXIgdG8gPSBjaGFuZ2VNZXRhLnRvO1xuICAgIHZhciBzdGFydCA9IHRvLnN0YXJ0O1xuICAgIHZhciBlbmQgPSB0by5lbmQ7XG4gICAgdmFyIHJlZiA9IGdldFNlcGFyYXRvcnMocHJvcHMpO1xuICAgIHZhciBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSByZWYuYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gcmVmLmRlY2ltYWxTZXBhcmF0b3I7XG4gICAgdmFyIGlzQmVmb3JlRGVjaW1hbFNlcGFyYXRvciA9IHZhbHVlW2VuZF0gPT09IGRlY2ltYWxTZXBhcmF0b3I7XG4gICAgLyoqXG4gICAgICogSWYgb25seSBhIG51bWJlciBpcyBhZGRlZCBvbiBlbXB0eSBpbnB1dCB3aGljaCBtYXRjaGVzIHdpdGggdGhlIHByZWZpeCBvciBzdWZmaXgsXG4gICAgICogdGhlbiBkb24ndCByZW1vdmUgaXQsIGp1c3QgcmV0dXJuIHRoZSBzYW1lXG4gICAgICovXG4gICAgaWYgKGNoYXJJc051bWJlcih2YWx1ZSkgJiZcbiAgICAgICAgKHZhbHVlID09PSBwcmVmaXggfHwgdmFsdWUgPT09IHN1ZmZpeCkgJiZcbiAgICAgICAgY2hhbmdlTWV0YS5sYXN0VmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIENoZWNrIGZvciBhbnkgYWxsb3dlZCBkZWNpbWFsIHNlcGFyYXRvciBpcyBhZGRlZCBpbiB0aGUgbnVtZXJpYyBmb3JtYXQgYW5kIHJlcGxhY2UgaXQgd2l0aCBkZWNpbWFsIHNlcGFyYXRvciAqL1xuICAgIGlmIChlbmQgLSBzdGFydCA9PT0gMSAmJiBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMuaW5kZXhPZih2YWx1ZVtzdGFydF0pICE9PSAtMSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gZGVjaW1hbFNjYWxlID09PSAwID8gJycgOiBkZWNpbWFsU2VwYXJhdG9yO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydCkgKyBzZXBhcmF0b3IgKyB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQgKyAxLCB2YWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgc3RyaXBOZWdhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYgcHJlZml4IHN0YXJ0cyB3aXRoIC0gd2UgZG9uJ3QgYWxsb3cgbmVnYXRpdmUgbnVtYmVyIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgICAgICAgKiBpZiBzdWZmaXggc3RhcnRzIHdpdGggLSBhbmQgdGhlIHZhbHVlIGxlbmd0aCBpcyBzYW1lIGFzIHN1ZmZpeCBsZW5ndGgsIHRoZW4gdGhlIC0gc2lnbiBpcyBmcm9tIHRoZSBzdWZmaXhcbiAgICAgICAgICogSW4gb3RoZXIgY2FzZXMsIGlmIHRoZSB2YWx1ZSBzdGFydHMgd2l0aCAtIHRoZW4gaXQgaXMgYSBuZWdhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhhc05lZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNEb3VibGVOZWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAocHJlZml4LnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgICAgICAgaGFzTmVnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgICAgICAgICBoYXNOZWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgaGFzRG91YmxlTmVnYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN1ZmZpeC5zdGFydHNXaXRoKCctJykgJiYgdmFsdWUubGVuZ3RoID09PSBzdWZmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBoYXNOZWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlWzBdID09PSAnLScpIHtcbiAgICAgICAgICAgIGhhc05lZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhcnNUb1JlbW92ZSA9IGhhc05lZ2F0aW9uID8gMSA6IDA7XG4gICAgICAgIGlmIChoYXNEb3VibGVOZWdhdGlvbilcbiAgICAgICAgICAgIHsgY2hhcnNUb1JlbW92ZSA9IDI7IH1cbiAgICAgICAgLy8gcmVtb3ZlIG5lZ2F0aW9uL2RvdWJsZSBuZWdhdGlvbiBmcm9tIHN0YXJ0IHRvIHNpbXBsaWZ5IHByZWZpeCBsb2dpYyBhcyBuZWdhdGlvbiBjb21lcyBiZWZvcmUgcHJlZml4XG4gICAgICAgIGlmIChjaGFyc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhjaGFyc1RvUmVtb3ZlKTtcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSByZW1vdmFsIG9mIHRoZSBuZWdhdGlvbiBmb3Igc3RhcnQgYW5kIGVuZCBpbmRleFxuICAgICAgICAgICAgc3RhcnQgLT0gY2hhcnNUb1JlbW92ZTtcbiAgICAgICAgICAgIGVuZCAtPSBjaGFyc1RvUmVtb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgaGFzTmVnYXRpb246IGhhc05lZ2F0aW9uIH07XG4gICAgfTtcbiAgICB2YXIgdG9NZXRhZGF0YSA9IHN0cmlwTmVnYXRpb24odmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIHZhciBoYXNOZWdhdGlvbiA9IHRvTWV0YWRhdGEuaGFzTmVnYXRpb247XG4gICAgKChhc3NpZ24gPSB0b01ldGFkYXRhLCB2YWx1ZSA9IGFzc2lnbi52YWx1ZSwgc3RhcnQgPSBhc3NpZ24uc3RhcnQsIGVuZCA9IGFzc2lnbi5lbmQpKTtcbiAgICB2YXIgcmVmJDEgPSBzdHJpcE5lZ2F0aW9uKGNoYW5nZU1ldGEubGFzdFZhbHVlLCBmcm9tLnN0YXJ0LCBmcm9tLmVuZCk7XG4gICAgdmFyIGZyb21TdGFydCA9IHJlZiQxLnN0YXJ0O1xuICAgIHZhciBmcm9tRW5kID0gcmVmJDEuZW5kO1xuICAgIHZhciBsYXN0VmFsdWUgPSByZWYkMS52YWx1ZTtcbiAgICAvLyBpZiBvbmx5IHByZWZpeCBhbmQgc3VmZml4IHBhcnQgaXMgdXBkYXRlZCByZXNldCB0aGUgdmFsdWUgdG8gbGFzdCB2YWx1ZVxuICAgIC8vIGlmIHRoZSBjaGFuZ2VkIHJhbmdlIGlzIGZyb20gc3VmZml4IGluIHRoZSB1cGRhdGVkIHZhbHVlLCBhbmQgdGhlIHRoZSBzdWZmaXggc3RhcnRzIHdpdGggdGhlIHNhbWUgY2hhcmFjdGVycywgYWxsb3cgdGhlIGNoYW5nZVxuICAgIHZhciB1cGRhdGVkU3VmZml4UGFydCA9IHZhbHVlLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoICYmXG4gICAgICAgIGxhc3RWYWx1ZS5sZW5ndGggJiZcbiAgICAgICAgKGZyb21TdGFydCA+IGxhc3RWYWx1ZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoIHx8IGZyb21FbmQgPCBwcmVmaXgubGVuZ3RoKSAmJlxuICAgICAgICAhKHVwZGF0ZWRTdWZmaXhQYXJ0ICYmIHN1ZmZpeC5zdGFydHNXaXRoKHVwZGF0ZWRTdWZmaXhQYXJ0KSkpIHtcbiAgICAgICAgdmFsdWUgPSBsYXN0VmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBwcmVmaXhcbiAgICAgKiBSZW1vdmUgd2hvbGUgcHJlZml4IHBhcnQgaWYgaXRzIHByZXNlbnQgb24gdGhlIHZhbHVlXG4gICAgICogSWYgdGhlIHByZWZpeCBpcyBwYXJ0aWFsbHkgZGVsZXRlZCAoaW4gd2hpY2ggY2FzZSBjaGFuZ2Ugc3RhcnQgaW5kZXggd2lsbCBiZSBsZXNzIHRoZSBwcmVmaXggbGVuZ3RoKVxuICAgICAqIFJlbW92ZSBvbmx5IHBhcnRpYWwgcGFydCBvZiBwcmVmaXguXG4gICAgICovXG4gICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgICAgIHsgc3RhcnRJbmRleCArPSBwcmVmaXgubGVuZ3RoOyB9XG4gICAgZWxzZSBpZiAoc3RhcnQgPCBwcmVmaXgubGVuZ3RoKVxuICAgICAgICB7IHN0YXJ0SW5kZXggPSBzdGFydDsgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xuICAgIC8vIGFjY291bnQgZm9yIGRlbGV0ZWQgcHJlZml4IGZvciBlbmRcbiAgICBlbmQgLT0gc3RhcnRJbmRleDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc3VmZml4XG4gICAgICogUmVtb3ZlIHdob2xlIHN1ZmZpeCBwYXJ0IGlmIGl0cyBwcmVzZW50IG9uIHRoZSB2YWx1ZVxuICAgICAqIElmIHRoZSBzdWZmaXggaXMgcGFydGlhbGx5IGRlbGV0ZWQgKGluIHdoaWNoIGNhc2UgY2hhbmdlIGVuZCBpbmRleCB3aWxsIGJlIGdyZWF0ZXIgdGhhbiB0aGUgc3VmZml4U3RhcnRJbmRleClcbiAgICAgKiByZW1vdmUgdGhlIHBhcnRpYWwgcGFydCBvZiBzdWZmaXhcbiAgICAgKi9cbiAgICB2YXIgZW5kSW5kZXggPSB2YWx1ZS5sZW5ndGg7XG4gICAgdmFyIHN1ZmZpeFN0YXJ0SW5kZXggPSB2YWx1ZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoO1xuICAgIGlmICh2YWx1ZS5lbmRzV2l0aChzdWZmaXgpKVxuICAgICAgICB7IGVuZEluZGV4ID0gc3VmZml4U3RhcnRJbmRleDsgfVxuICAgIC8vIGlmIHRoZSBzdWZmaXggaXMgcmVtb3ZlZCBmcm9tIHRoZSBlbmRcbiAgICBlbHNlIGlmIChlbmQgPiBzdWZmaXhTdGFydEluZGV4KVxuICAgICAgICB7IGVuZEluZGV4ID0gZW5kOyB9XG4gICAgLy8gaWYgdGhlIHN1ZmZpeCBpcyByZW1vdmVkIGZyb20gc3RhcnRcbiAgICBlbHNlIGlmIChlbmQgPiB2YWx1ZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKVxuICAgICAgICB7IGVuZEluZGV4ID0gZW5kOyB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgZW5kSW5kZXgpO1xuICAgIC8vIGFkZCB0aGUgbmVnYXRpb24gYmFjayBhbmQgaGFuZGxlIGZvciBkb3VibGUgbmVnYXRpb25cbiAgICB2YWx1ZSA9IGhhbmRsZU5lZ2F0aW9uKGhhc05lZ2F0aW9uID8gKFwiLVwiICsgdmFsdWUpIDogdmFsdWUsIGFsbG93TmVnYXRpdmUpO1xuICAgIC8vIHJlbW92ZSBub24gbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgdmFsdWUgPSAodmFsdWUubWF0Y2goZ2V0TnVtYmVyUmVnZXgoZGVjaW1hbFNlcGFyYXRvciwgdHJ1ZSkpIHx8IFtdKS5qb2luKCcnKTtcbiAgICAvLyByZXBsYWNlIHRoZSBkZWNpbWFsU2VwYXJhdG9yIHdpdGggLiwgYW5kIG9ubHkga2VlcCB0aGUgZmlyc3Qgc2VwYXJhdG9yLCBpZ25vcmUgZm9sbG93aW5nIG9uZXNcbiAgICB2YXIgZmlyc3RJbmRleCA9IHZhbHVlLmluZGV4T2YoZGVjaW1hbFNlcGFyYXRvcik7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpLCAnZycpLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gZmlyc3RJbmRleCA/ICcuJyA6ICcnO1xuICAgIH0pO1xuICAgIC8vY2hlY2sgaWYgYmVmb3JlRGVjaW1hbCBnb3QgZGVsZXRlZCBhbmQgdGhlcmUgaXMgbm90aGluZyBhZnRlciBkZWNpbWFsLFxuICAgIC8vY2xlYXIgYWxsIG51bWJlcnMgaW4gc3VjaCBjYXNlIHdoaWxlIGtlZXBpbmcgdGhlIC0gc2lnblxuICAgIHZhciByZWYkMiA9IHNwbGl0RGVjaW1hbCh2YWx1ZSwgYWxsb3dOZWdhdGl2ZSk7XG4gICAgdmFyIGJlZm9yZURlY2ltYWwgPSByZWYkMi5iZWZvcmVEZWNpbWFsO1xuICAgIHZhciBhZnRlckRlY2ltYWwgPSByZWYkMi5hZnRlckRlY2ltYWw7XG4gICAgdmFyIGFkZE5lZ2F0aW9uID0gcmVmJDIuYWRkTmVnYXRpb247IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgLy9jbGVhciBvbmx5IGlmIHNvbWV0aGluZyBnb3QgZGVsZXRlZCBiZWZvcmUgZGVjaW1hbCAoY3Vyc29yIGlzIGJlZm9yZSBkZWNpbWFsKVxuICAgIGlmICh0by5lbmQgLSB0by5zdGFydCA8IGZyb20uZW5kIC0gZnJvbS5zdGFydCAmJlxuICAgICAgICBiZWZvcmVEZWNpbWFsID09PSAnJyAmJlxuICAgICAgICBpc0JlZm9yZURlY2ltYWxTZXBhcmF0b3IgJiZcbiAgICAgICAgIXBhcnNlRmxvYXQoYWZ0ZXJEZWNpbWFsKSkge1xuICAgICAgICB2YWx1ZSA9IGFkZE5lZ2F0aW9uID8gJy0nIDogJyc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENhcmV0Qm91bmRhcnkoZm9ybWF0dGVkVmFsdWUsIHByb3BzKSB7XG4gICAgdmFyIHByZWZpeCA9IHByb3BzLnByZWZpeDsgaWYgKCBwcmVmaXggPT09IHZvaWQgMCApIHByZWZpeCA9ICcnO1xuICAgIHZhciBzdWZmaXggPSBwcm9wcy5zdWZmaXg7IGlmICggc3VmZml4ID09PSB2b2lkIDAgKSBzdWZmaXggPSAnJztcbiAgICB2YXIgYm91bmRhcnlBcnkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggKyAxIH0pLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB2YXIgaGFzTmVnYXRpb24gPSBmb3JtYXR0ZWRWYWx1ZVswXSA9PT0gJy0nO1xuICAgIC8vIGZpbGwgZm9yIHByZWZpeCBhbmQgbmVnYXRpb25cbiAgICBib3VuZGFyeUFyeS5maWxsKGZhbHNlLCAwLCBwcmVmaXgubGVuZ3RoICsgKGhhc05lZ2F0aW9uID8gMSA6IDApKTtcbiAgICAvLyBmaWxsIGZvciBzdWZmaXhcbiAgICB2YXIgdmFsTG4gPSBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGg7XG4gICAgYm91bmRhcnlBcnkuZmlsbChmYWxzZSwgdmFsTG4gLSBzdWZmaXgubGVuZ3RoICsgMSwgdmFsTG4gKyAxKTtcbiAgICByZXR1cm4gYm91bmRhcnlBcnk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFVwZGF0ZVByb3BzKHByb3BzKSB7XG4gICAgdmFyIHJlZiA9IGdldFNlcGFyYXRvcnMocHJvcHMpO1xuICAgIHZhciB0aG91c2FuZFNlcGFyYXRvciA9IHJlZi50aG91c2FuZFNlcGFyYXRvcjtcbiAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IHJlZi5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICB2YXIgcHJlZml4ID0gcHJvcHMucHJlZml4OyBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG4gICAgdmFyIGFsbG93TmVnYXRpdmUgPSBwcm9wcy5hbGxvd05lZ2F0aXZlOyBpZiAoIGFsbG93TmVnYXRpdmUgPT09IHZvaWQgMCApIGFsbG93TmVnYXRpdmUgPSB0cnVlO1xuICAgIGlmICh0aG91c2FuZFNlcGFyYXRvciA9PT0gZGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiXFxuICAgICAgICBEZWNpbWFsIHNlcGFyYXRvciBjYW4ndCBiZSBzYW1lIGFzIHRob3VzYW5kIHNlcGFyYXRvci5cXG4gICAgICAgIHRob3VzYW5kU2VwYXJhdG9yOiBcIiArIHRob3VzYW5kU2VwYXJhdG9yICsgXCIgKHRob3VzYW5kU2VwYXJhdG9yID0ge3RydWV9IGlzIHNhbWUgYXMgdGhvdXNhbmRTZXBhcmF0b3IgPSBcXFwiLFxcXCIpXFxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiBcIiArIGRlY2ltYWxTZXBhcmF0b3IgKyBcIiAoZGVmYXVsdCB2YWx1ZSBmb3IgZGVjaW1hbFNlcGFyYXRvciBpcyAuKVxcbiAgICAgXCIpKTtcbiAgICB9XG4gICAgaWYgKHByZWZpeC5zdGFydHNXaXRoKCctJykgJiYgYWxsb3dOZWdhdGl2ZSkge1xuICAgICAgICAvLyBUT0RPOiB0aHJvdyBlcnJvciBpbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJcXG4gICAgICBQcmVmaXggY2FuJ3Qgc3RhcnQgd2l0aCAnLScgd2hlbiBhbGxvd05lZ2F0aXZlIGlzIHRydWUuXFxuICAgICAgcHJlZml4OiBcIiArIHByZWZpeCArIFwiXFxuICAgICAgYWxsb3dOZWdhdGl2ZTogXCIgKyBhbGxvd05lZ2F0aXZlICsgXCJcXG4gICAgXCIpKTtcbiAgICAgICAgYWxsb3dOZWdhdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgYWxsb3dOZWdhdGl2ZTogYWxsb3dOZWdhdGl2ZSB9KTtcbn1cbmZ1bmN0aW9uIHVzZU51bWVyaWNGb3JtYXQocHJvcHMpIHtcbiAgICAvLyB2YWxpZGF0ZSBwcm9wc1xuICAgIHByb3BzID0gdmFsaWRhdGVBbmRVcGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgdmFyIF9kZWNpbWFsU2VwYXJhdG9yID0gcHJvcHMuZGVjaW1hbFNlcGFyYXRvcjtcbiAgICB2YXIgX2FsbG93ZWREZWNpbWFsU2VwYXJhdG9ycyA9IHByb3BzLmFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycztcbiAgICB2YXIgdGhvdXNhbmRzR3JvdXBTdHlsZSA9IHByb3BzLnRob3VzYW5kc0dyb3VwU3R5bGU7XG4gICAgdmFyIHN1ZmZpeCA9IHByb3BzLnN1ZmZpeDtcbiAgICB2YXIgYWxsb3dOZWdhdGl2ZSA9IHByb3BzLmFsbG93TmVnYXRpdmU7XG4gICAgdmFyIGFsbG93TGVhZGluZ1plcm9zID0gcHJvcHMuYWxsb3dMZWFkaW5nWmVyb3M7XG4gICAgdmFyIG9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bjsgaWYgKCBvbktleURvd24gPT09IHZvaWQgMCApIG9uS2V5RG93biA9IG5vb3A7XG4gICAgdmFyIG9uQmx1ciA9IHByb3BzLm9uQmx1cjsgaWYgKCBvbkJsdXIgPT09IHZvaWQgMCApIG9uQmx1ciA9IG5vb3A7XG4gICAgdmFyIHRob3VzYW5kU2VwYXJhdG9yID0gcHJvcHMudGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgdmFyIGRlY2ltYWxTY2FsZSA9IHByb3BzLmRlY2ltYWxTY2FsZTtcbiAgICB2YXIgZml4ZWREZWNpbWFsU2NhbGUgPSBwcm9wcy5maXhlZERlY2ltYWxTY2FsZTtcbiAgICB2YXIgcHJlZml4ID0gcHJvcHMucHJlZml4OyBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICB2YXIgdmFsdWVJc051bWVyaWNTdHJpbmcgPSBwcm9wcy52YWx1ZUlzTnVtZXJpY1N0cmluZztcbiAgICB2YXIgb25WYWx1ZUNoYW5nZSA9IHByb3BzLm9uVmFsdWVDaGFuZ2U7XG4gICAgdmFyIHJlc3RQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiZGVjaW1hbFNlcGFyYXRvclwiLCBcImFsbG93ZWREZWNpbWFsU2VwYXJhdG9yc1wiLCBcInRob3VzYW5kc0dyb3VwU3R5bGVcIiwgXCJzdWZmaXhcIiwgXCJhbGxvd05lZ2F0aXZlXCIsIFwiYWxsb3dMZWFkaW5nWmVyb3NcIiwgXCJvbktleURvd25cIiwgXCJvbkJsdXJcIiwgXCJ0aG91c2FuZFNlcGFyYXRvclwiLCBcImRlY2ltYWxTY2FsZVwiLCBcImZpeGVkRGVjaW1hbFNjYWxlXCIsIFwicHJlZml4XCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwidmFsdWVcIiwgXCJ2YWx1ZUlzTnVtZXJpY1N0cmluZ1wiLCBcIm9uVmFsdWVDaGFuZ2VcIl0pO1xuICAgIC8vIGdldCBkZXJpdmVkIGRlY2ltYWxTZXBhcmF0b3IgYW5kIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9yc1xuICAgIHZhciByZWYgPSBnZXRTZXBhcmF0b3JzKHByb3BzKTtcbiAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IHJlZi5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIHZhciBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPSByZWYuYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzO1xuICAgIHZhciBfZm9ybWF0ID0gZnVuY3Rpb24gKG51bVN0cikgeyByZXR1cm4gZm9ybWF0KG51bVN0ciwgcHJvcHMpOyB9O1xuICAgIHZhciBfcmVtb3ZlRm9ybWF0dGluZyA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlLCBjaGFuZ2VNZXRhKSB7IHJldHVybiByZW1vdmVGb3JtYXR0aW5nKGlucHV0VmFsdWUsIGNoYW5nZU1ldGEsIHByb3BzKTsgfTtcbiAgICB2YXIgX3ZhbHVlID0gaXNOaWwodmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgLy8gdHJ5IHRvIGZpZ3VyZSBvdXQgaXNWYWx1ZU51bWVyaWNTdHJpbmcgYmFzZWQgb24gZm9ybWF0IHByb3AgYW5kIHZhbHVlXG4gICAgdmFyIF92YWx1ZUlzTnVtZXJpY1N0cmluZyA9IHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSBudWxsICYmIHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSB2b2lkIDAgPyB2YWx1ZUlzTnVtZXJpY1N0cmluZyA6IGlzTnVtZXJpY1N0cmluZyhfdmFsdWUsIHByZWZpeCwgc3VmZml4KTtcbiAgICBpZiAoIWlzTmlsKHZhbHVlKSkge1xuICAgICAgICBfdmFsdWVJc051bWVyaWNTdHJpbmcgPSBfdmFsdWVJc051bWVyaWNTdHJpbmcgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzTmlsKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgX3ZhbHVlSXNOdW1lcmljU3RyaW5nID0gX3ZhbHVlSXNOdW1lcmljU3RyaW5nIHx8IHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICB2YXIgcm91bmRJbmNvbWluZ1ZhbHVlVG9QcmVjaXNpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTm90VmFsaWRWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICB7IHJldHVybiB2YWx1ZTsgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0b051bWVyaWNTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbmx5IHJvdW5kIG51bWVyaWMgb3IgZmxvYXQgc3RyaW5nIHZhbHVlcyBjb21pbmcgdGhyb3VnaCBwcm9wcyxcbiAgICAgICAgICogd2UgZG9uJ3QgbmVlZCB0byBkbyBpdCBmb3Igb25DaGFuZ2UgZXZlbnRzLCBhcyB3ZSB3YW50IHRvIHByZXZlbnQgdHlwaW5nIHRoZXJlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoX3ZhbHVlSXNOdW1lcmljU3RyaW5nICYmIHR5cGVvZiBkZWNpbWFsU2NhbGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmRUb1ByZWNpc2lvbih2YWx1ZSwgZGVjaW1hbFNjYWxlLCBCb29sZWFuKGZpeGVkRGVjaW1hbFNjYWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgdmFyIHJlZiQxID0gdXNlSW50ZXJuYWxWYWx1ZXMocm91bmRJbmNvbWluZ1ZhbHVlVG9QcmVjaXNpb24odmFsdWUpLCByb3VuZEluY29taW5nVmFsdWVUb1ByZWNpc2lvbihkZWZhdWx0VmFsdWUpLCBCb29sZWFuKF92YWx1ZUlzTnVtZXJpY1N0cmluZyksIF9mb3JtYXQsIF9yZW1vdmVGb3JtYXR0aW5nLCBvblZhbHVlQ2hhbmdlKTtcbiAgICB2YXIgcmVmJDFfMCA9IHJlZiQxWzBdO1xuICAgIHZhciBudW1Bc1N0cmluZyA9IHJlZiQxXzAubnVtQXNTdHJpbmc7XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gcmVmJDFfMC5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB2YXIgX29uVmFsdWVDaGFuZ2UgPSByZWYkMVsxXTtcbiAgICB2YXIgX29uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIga2V5ID0gZS5rZXk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gZWwuc2VsZWN0aW9uRW5kO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbC52YWx1ZTsgaWYgKCB2YWx1ZSA9PT0gdm9pZCAwICkgdmFsdWUgPSAnJztcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgY2hhcmFjdGVycyBhcmUgc2VsZWN0ZWQgYW5kIHVzZXIgaGl0cyBiYWNrc3BhY2UsIG5vIG5lZWQgdG8gaGFuZGxlIGFueXRoaW5nIG1hbnVhbGx5XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICBvbktleURvd24oZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXNlciBoaXRzIGJhY2tzcGFjZSwgd2hpbGUgdGhlIGN1cnNvciBpcyBiZWZvcmUgcHJlZml4LCBhbmQgdGhlIGlucHV0IGhhcyBuZWdhdGlvbiwgcmVtb3ZlIHRoZSBuZWdhdGlvblxuICAgICAgICBpZiAoa2V5ID09PSAnQmFja3NwYWNlJyAmJlxuICAgICAgICAgICAgdmFsdWVbMF0gPT09ICctJyAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQgPT09IHByZWZpeC5sZW5ndGggKyAxICYmXG4gICAgICAgICAgICBhbGxvd05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAvLyBicmluZyB0aGUgY3Vyc29yIHRvIGFmdGVyIG5lZ2F0aW9uXG4gICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb24ndCBhbGxvdyB1c2VyIHRvIGRlbGV0ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGVuIGRlY2ltYWxTY2FsZSBhbmQgZml4ZWREZWNpbWFsU2NhbGUgaXMgc2V0XG4gICAgICAgIGlmIChkZWNpbWFsU2NhbGUgJiYgZml4ZWREZWNpbWFsU2NhbGUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnICYmIHZhbHVlW3NlbGVjdGlvblN0YXJ0IC0gMV0gPT09IGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCBzZWxlY3Rpb25TdGFydCAtIDEpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ0RlbGV0ZScgJiYgdmFsdWVbc2VsZWN0aW9uU3RhcnRdID09PSBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHVzZXIgcHJlc3NlcyB0aGUgYWxsb3dlZCBkZWNpbWFsIHNlcGFyYXRvciBiZWZvcmUgdGhlIHNlcGFyYXRvciwgbW92ZSB0aGUgY3Vyc29yIGFmdGVyIHRoZSBzZXBhcmF0b3JcbiAgICAgICAgaWYgKChhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMgPT09IG51bGwgfHwgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMuaW5jbHVkZXMoa2V5KSkgJiYgdmFsdWVbc2VsZWN0aW9uU3RhcnRdID09PSBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCBzZWxlY3Rpb25TdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhvdXNhbmRTZXBhcmF0b3IgPSB0aG91c2FuZFNlcGFyYXRvciA9PT0gdHJ1ZSA/ICcsJyA6IHRob3VzYW5kU2VwYXJhdG9yO1xuICAgICAgICAvLyBtb3ZlIGN1cnNvciB3aGVuIGRlbGV0ZSBvciBiYWNrc3BhY2UgaXMgcHJlc3NlZCBiZWZvcmUvYWZ0ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnICYmIHZhbHVlW3NlbGVjdGlvblN0YXJ0IC0gMV0gPT09IF90aG91c2FuZFNlcGFyYXRvcikge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgc2VsZWN0aW9uU3RhcnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnRGVsZXRlJyAmJiB2YWx1ZVtzZWxlY3Rpb25TdGFydF0gPT09IF90aG91c2FuZFNlcGFyYXRvcikge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlbCwgc2VsZWN0aW9uU3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBvbktleURvd24oZSk7XG4gICAgfTtcbiAgICB2YXIgX29uQmx1ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBudW1Bc1N0cmluZztcbiAgICAgICAgLy8gaWYgdGhlcmUgbm8gbm8gbnVtZXJpYyB2YWx1ZSwgY2xlYXIgdGhlIGlucHV0XG4gICAgICAgIGlmICghX3ZhbHVlLm1hdGNoKC9cXGQvZykpIHtcbiAgICAgICAgICAgIF92YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIGxlYWRpbmcgMHNcbiAgICAgICAgaWYgKCFhbGxvd0xlYWRpbmdaZXJvcykge1xuICAgICAgICAgICAgX3ZhbHVlID0gZml4TGVhZGluZ1plcm8oX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBmaXhlZERlY2ltYWxTY2FsZSBvbiBibHVyIGV2ZW50XG4gICAgICAgIGlmIChmaXhlZERlY2ltYWxTY2FsZSAmJiBkZWNpbWFsU2NhbGUpIHtcbiAgICAgICAgICAgIF92YWx1ZSA9IHJvdW5kVG9QcmVjaXNpb24oX3ZhbHVlLCBkZWNpbWFsU2NhbGUsIGZpeGVkRGVjaW1hbFNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3ZhbHVlICE9PSBudW1Bc1N0cmluZykge1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0KF92YWx1ZSwgcHJvcHMpO1xuICAgICAgICAgICAgX29uVmFsdWVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZhbHVlLFxuICAgICAgICAgICAgICAgIGZsb2F0VmFsdWU6IHBhcnNlRmxvYXQoX3ZhbHVlKSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFNvdXJjZVR5cGUuZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbkJsdXIoZSk7XG4gICAgfTtcbiAgICB2YXIgaXNWYWxpZElucHV0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKGlucHV0Q2hhcikge1xuICAgICAgICBpZiAoaW5wdXRDaGFyID09PSBkZWNpbWFsU2VwYXJhdG9yKVxuICAgICAgICAgICAgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gY2hhcklzTnVtYmVyKGlucHV0Q2hhcik7XG4gICAgfTtcbiAgICB2YXIgaXNDaGFyYWN0ZXJTYW1lID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gcmVmLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHJlZi5sYXN0VmFsdWU7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHJlZi5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZUluZGV4ID0gcmVmLmN1cnJlbnRWYWx1ZUluZGV4O1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWVJbmRleCA9IHJlZi5mb3JtYXR0ZWRWYWx1ZUluZGV4O1xuXG4gICAgICAgIHZhciBjdXJDaGFyID0gY3VycmVudFZhbHVlW2N1cnJlbnRWYWx1ZUluZGV4XTtcbiAgICAgICAgdmFyIG5ld0NoYXIgPSBmb3JtYXR0ZWRWYWx1ZVtmb3JtYXR0ZWRWYWx1ZUluZGV4XTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5PVEU6IGFzIHRob3VzYW5kIHNlcGFyYXRvciBhbmQgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzIGNhbiBiZSBzYW1lLCB3ZSBuZWVkIHRvIGNoZWNrIG9uXG4gICAgICAgICAqIHR5cGVkIHJhbmdlIGlmIHdlIGhhdmUgdHlwZWQgYW55IGNoYXJhY3RlciBmcm9tIGFsbG93ZWREZWNpbWFsU2VwYXJhdG9ycywgaW4gdGhhdCBjYXNlIHdlXG4gICAgICAgICAqIGNvbnNpZGVyIGRpZmZlcmVudCBjaGFyYWN0ZXJzIGxpa2UgLCBhbmQgLiBzYW1lIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdXBkYXRlZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciB0eXBlZFJhbmdlID0gZmluZENoYW5nZVJhbmdlKGxhc3RWYWx1ZSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgdmFyIHRvID0gdHlwZWRSYW5nZS50bztcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZUluZGV4ID49IHRvLnN0YXJ0ICYmXG4gICAgICAgICAgICBjdXJyZW50VmFsdWVJbmRleCA8IHRvLmVuZCAmJlxuICAgICAgICAgICAgYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzICYmXG4gICAgICAgICAgICBhbGxvd2VkRGVjaW1hbFNlcGFyYXRvcnMuaW5jbHVkZXMoY3VyQ2hhcikgJiZcbiAgICAgICAgICAgIG5ld0NoYXIgPT09IGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJDaGFyID09PSBuZXdDaGFyO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdFByb3BzKSwgeyB2YWx1ZTogZm9ybWF0dGVkVmFsdWUsIHZhbHVlSXNOdW1lcmljU3RyaW5nOiBmYWxzZSwgaXNWYWxpZElucHV0Q2hhcmFjdGVyOiBpc1ZhbGlkSW5wdXRDaGFyYWN0ZXIsXG4gICAgICAgIGlzQ2hhcmFjdGVyU2FtZTogaXNDaGFyYWN0ZXJTYW1lLCBvblZhbHVlQ2hhbmdlOiBfb25WYWx1ZUNoYW5nZSwgZm9ybWF0OiBfZm9ybWF0LCByZW1vdmVGb3JtYXR0aW5nOiBfcmVtb3ZlRm9ybWF0dGluZywgZ2V0Q2FyZXRCb3VuZGFyeTogZnVuY3Rpb24gKGZvcm1hdHRlZFZhbHVlKSB7IHJldHVybiBnZXRDYXJldEJvdW5kYXJ5KGZvcm1hdHRlZFZhbHVlLCBwcm9wcyk7IH0sIG9uS2V5RG93bjogX29uS2V5RG93biwgb25CbHVyOiBfb25CbHVyIH0pO1xufVxuZnVuY3Rpb24gTnVtZXJpY0Zvcm1hdChwcm9wcykge1xuICAgIHZhciBudW1lcmljRm9ybWF0UHJvcHMgPSB1c2VOdW1lcmljRm9ybWF0KHByb3BzKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOdW1iZXJGb3JtYXRCYXNlLCBPYmplY3QuYXNzaWduKHt9LCBudW1lcmljRm9ybWF0UHJvcHMpKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0JDEobnVtU3RyLCBwcm9wcykge1xuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7XG4gICAgdmFyIGFsbG93RW1wdHlGb3JtYXR0aW5nID0gcHJvcHMuYWxsb3dFbXB0eUZvcm1hdHRpbmc7XG4gICAgdmFyIG1hc2sgPSBwcm9wcy5tYXNrO1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICBpZiAobnVtU3RyID09PSAnJyAmJiAhYWxsb3dFbXB0eUZvcm1hdHRpbmcpXG4gICAgICAgIHsgcmV0dXJuICcnOyB9XG4gICAgdmFyIGhhc2hDb3VudCA9IDA7XG4gICAgdmFyIGZvcm1hdHRlZE51bWJlckFyeSA9IGZvcm1hdC5zcGxpdCgnJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxuID0gZm9ybWF0Lmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFtpXSA9PT0gcGF0dGVybkNoYXIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlckFyeVtpXSA9IG51bVN0cltoYXNoQ291bnRdIHx8IGdldE1hc2tBdEluZGV4KG1hc2ssIGhhc2hDb3VudCk7XG4gICAgICAgICAgICBoYXNoQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyQXJ5LmpvaW4oJycpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZyQxKHZhbHVlLCBjaGFuZ2VNZXRhLCBwcm9wcykge1xuICAgIGlmICggY2hhbmdlTWV0YSA9PT0gdm9pZCAwICkgY2hhbmdlTWV0YSA9IGdldERlZmF1bHRDaGFuZ2VNZXRhKHZhbHVlKTtcblxuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7XG4gICAgdmFyIHBhdHRlcm5DaGFyID0gcHJvcHMucGF0dGVybkNoYXI7IGlmICggcGF0dGVybkNoYXIgPT09IHZvaWQgMCApIHBhdHRlcm5DaGFyID0gJyMnO1xuICAgIHZhciBmcm9tID0gY2hhbmdlTWV0YS5mcm9tO1xuICAgIHZhciB0byA9IGNoYW5nZU1ldGEudG87XG4gICAgdmFyIGxhc3RWYWx1ZSA9IGNoYW5nZU1ldGEubGFzdFZhbHVlOyBpZiAoIGxhc3RWYWx1ZSA9PT0gdm9pZCAwICkgbGFzdFZhbHVlID0gJyc7XG4gICAgdmFyIGlzTnVtZXJpY1Nsb3QgPSBmdW5jdGlvbiAoY2FyZXRQb3MpIHsgcmV0dXJuIGZvcm1hdFtjYXJldFBvc10gPT09IHBhdHRlcm5DaGFyOyB9O1xuICAgIHZhciByZW1vdmVGb3JtYXRDaGFyID0gZnVuY3Rpb24gKHN0cmluZywgc3RhcnRJbmRleCkge1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljU2xvdChzdGFydEluZGV4ICsgaSkgJiYgY2hhcklzTnVtYmVyKHN0cmluZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gc3RyaW5nW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICB2YXIgZXh0cmFjdE51bWJlcnMgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvW14wLTldL2csICcnKTsgfTtcbiAgICAvLyBpZiBmb3JtYXQgZG9lc24ndCBoYXZlIGFueSBudW1iZXIsIHJlbW92ZSBhbGwgdGhlIG5vbiBudW1lcmljIGNoYXJhY3RlcnNcbiAgICBpZiAoIWZvcm1hdC5tYXRjaCgvXFxkLykpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3ROdW1iZXJzKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaWYgdXNlciBwYXN0ZSB0aGUgd2hvbGUgZm9ybWF0dGVkIHRleHQgaW4gYW4gZW1wdHkgaW5wdXQsIGNoZWNrIGlmIG1hdGNoZXMgdG8gdGhlIHBhdHRlcm5cbiAgICAgKiBhbmQgcmVtb3ZlIHRoZSBmb3JtYXQgY2hhcmFjdGVycywgaWYgdGhlcmUgaXMgYSBtaXNtYXRjaCBvbiB0aGUgcGF0dGVybiwgZG8gcGxhbmUgbnVtYmVyIGV4dHJhY3RcbiAgICAgKi9cbiAgICBpZiAobGFzdFZhbHVlID09PSAnJyAmJiB2YWx1ZS5sZW5ndGggPT09IGZvcm1hdC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljU2xvdChpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFySXNOdW1iZXIodmFsdWVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVtpXSAhPT0gZm9ybWF0W2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBtaXNtYXRjaCBvbiB0aGUgcGF0dGVybiwgZG8gcGxhbmUgbnVtYmVyIGV4dHJhY3RcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFjdE51bWJlcnModmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBwYXJ0aWFsIGNoYW5nZSxcbiAgICAgKiB3aGVyZSBldmVyIHRoZXJlIGlzIGEgY2hhbmdlIG9uIHRoZSBpbnB1dCwgd2UgY2FuIGJyZWFrIHRoZSBudW1iZXIgaW4gdGhyZWUgcGFydHNcbiAgICAgKiAxc3Q6IGxlZnQgcGFydCB3aGljaCBpcyB1bmNoYW5nZWRcbiAgICAgKiAybmQ6IG1pZGRsZSBwYXJ0IHdoaWNoIGlzIGNoYW5nZWRcbiAgICAgKiAzcmQ6IHJpZ2h0IHBhcnQgd2hpY2ggaXMgdW5jaGFuZ2VkXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgYW5kIHRoaXJkIHNlY3Rpb24gd2lsbCBiZSBzYW1lIGFzIGxhc3QgdmFsdWUsIG9ubHkgdGhlIG1pZGRsZSBwYXJ0IHdpbGwgY2hhbmdlXG4gICAgICogV2UgY2FuIGNvbnNpZGVyIG9uIHRoZSBjaGFuZ2UgcGFydCBhbGwgdGhlIG5ldyBjaGFyYWN0ZXJzIGFyZSBub24gZm9ybWF0IGNoYXJhY3RlcnMuXG4gICAgICogQW5kIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWN0aW9uIGl0IGNhbiBoYXZlIHBhcnRpYWwgZm9ybWF0IGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBXZSBwaWNrIGZpcnN0IGFuZCBsYXN0IHNlY3Rpb24gZnJvbSB0aGUgbGFzdFZhbHVlIChhcyB0aGF0IGhhcyAxLTEgbWFwcGluZyB3aXRoIGZvcm1hdClcbiAgICAgKiBhbmQgbWlkZGxlIG9uZSBmcm9tIHRoZSB1cGRhdGUgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGZpcnN0U2VjdGlvbiA9IGxhc3RWYWx1ZS5zdWJzdHJpbmcoMCwgZnJvbS5zdGFydCk7XG4gICAgdmFyIG1pZGRsZVNlY3Rpb24gPSB2YWx1ZS5zdWJzdHJpbmcodG8uc3RhcnQsIHRvLmVuZCk7XG4gICAgdmFyIGxhc3RTZWN0aW9uID0gbGFzdFZhbHVlLnN1YnN0cmluZyhmcm9tLmVuZCk7XG4gICAgcmV0dXJuIChcIlwiICsgKHJlbW92ZUZvcm1hdENoYXIoZmlyc3RTZWN0aW9uLCAwKSkgKyAoZXh0cmFjdE51bWJlcnMobWlkZGxlU2VjdGlvbikpICsgKHJlbW92ZUZvcm1hdENoYXIobGFzdFNlY3Rpb24sIGZyb20uZW5kKSkpO1xufVxuZnVuY3Rpb24gZ2V0Q2FyZXRCb3VuZGFyeSQxKGZvcm1hdHRlZFZhbHVlLCBwcm9wcykge1xuICAgIHZhciBmb3JtYXQgPSBwcm9wcy5mb3JtYXQ7XG4gICAgdmFyIG1hc2sgPSBwcm9wcy5tYXNrO1xuICAgIHZhciBwYXR0ZXJuQ2hhciA9IHByb3BzLnBhdHRlcm5DaGFyOyBpZiAoIHBhdHRlcm5DaGFyID09PSB2b2lkIDAgKSBwYXR0ZXJuQ2hhciA9ICcjJztcbiAgICB2YXIgYm91bmRhcnlBcnkgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggKyAxIH0pLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB2YXIgaGFzaENvdW50ID0gMDtcbiAgICB2YXIgZmlyc3RFbXB0eVNsb3QgPSAtMTtcbiAgICB2YXIgbWFza0FuZEluZGV4TWFwID0ge307XG4gICAgZm9ybWF0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyLCBpbmRleCkge1xuICAgICAgICB2YXIgbWFza0F0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjaGFyID09PSBwYXR0ZXJuQ2hhcikge1xuICAgICAgICAgICAgaGFzaENvdW50Kys7XG4gICAgICAgICAgICBtYXNrQXRJbmRleCA9IGdldE1hc2tBdEluZGV4KG1hc2ssIGhhc2hDb3VudCAtIDEpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RW1wdHlTbG90ID09PSAtMSAmJiBmb3JtYXR0ZWRWYWx1ZVtpbmRleF0gPT09IG1hc2tBdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbXB0eVNsb3QgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXNrQW5kSW5kZXhNYXBbaW5kZXhdID0gbWFza0F0SW5kZXg7XG4gICAgfSk7XG4gICAgdmFyIGlzUG9zQWxsb3dlZCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgLy8gdGhlIHBvc2l0aW9uIGlzIGFsbG93ZWQgaWYgdGhlIHBvc2l0aW9uIGlzIG5vdCBtYXNrZWQgYW5kIHZhbGlkIG51bWJlciBhcmVhXG4gICAgICAgIHJldHVybiBmb3JtYXRbcG9zXSA9PT0gcGF0dGVybkNoYXIgJiYgZm9ybWF0dGVkVmFsdWVbcG9zXSAhPT0gbWFza0FuZEluZGV4TWFwW3Bvc107XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMCwgbG4gPSBib3VuZGFyeUFyeS5sZW5ndGg7IGkgPCBsbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvbnNpZGVyIGNhcmV0IHRvIGJlIGluIGJvdW5kYXJ5IGlmIGl0IGlzIGJlZm9yZSBvciBhZnRlciBudW1lcmljIHZhbHVlXG4gICAgICAgIC8vIE5vdGU6IG9uIHBhdHRlcm4gYmFzZWQgZm9ybWF0IGl0cyBkZW5vdGVkIGJ5IHBhdHRlcm5DaGFyYWN0ZXJcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsc28gYWxsb3cgdXNlciB0byBwdXQgY3Vyc29yIG9uIGZpcnN0IGVtcHR5IHNsb3RcbiAgICAgICAgYm91bmRhcnlBcnlbaV0gPSBpID09PSBmaXJzdEVtcHR5U2xvdCB8fCBpc1Bvc0FsbG93ZWQoaSkgfHwgaXNQb3NBbGxvd2VkKGkgLSAxKTtcbiAgICB9XG4gICAgLy8gdGhlIGZpcnN0IHBhdHRlcm5DaGFyIHBvc2l0aW9uIGlzIGFsd2F5cyBhbGxvd2VkXG4gICAgYm91bmRhcnlBcnlbZm9ybWF0LmluZGV4T2YocGF0dGVybkNoYXIpXSA9IHRydWU7XG4gICAgcmV0dXJuIGJvdW5kYXJ5QXJ5O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwcm9wcykge1xuICAgIHZhciBtYXNrID0gcHJvcHMubWFzaztcbiAgICBpZiAobWFzaykge1xuICAgICAgICB2YXIgbWFza0FzU3RyID0gbWFzayA9PT0gJ3N0cmluZycgPyBtYXNrIDogbWFzay50b1N0cmluZygpO1xuICAgICAgICBpZiAobWFza0FzU3RyLm1hdGNoKC9cXGQvZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJNYXNrIFwiICsgbWFzayArIFwiIHNob3VsZCBub3QgY29udGFpbiBudW1lcmljIGNoYXJhY3RlcjtcIikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOdW1lcmljU3RyaW5nJDEodmFsLCBmb3JtYXQpIHtcbiAgICAvL3dlIGNhbiB0cmVhdCBlbXB0eSBzdHJpbmcgYXMgbnVtZXJpYyBzdHJpbmdcbiAgICBpZiAodmFsID09PSAnJylcbiAgICAgICAgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJldHVybiAhKGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5tYXRjaCgvXFxkLykpICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmICghIXZhbC5tYXRjaCgvXlxcZCskLykgfHwgdmFsID09PSAnJyk7XG59XG5mdW5jdGlvbiB1c2VQYXR0ZXJuRm9ybWF0KHByb3BzKSB7XG4gICAgdmFyIG1hc2sgPSBwcm9wcy5tYXNrO1xuICAgIHZhciBhbGxvd0VtcHR5Rm9ybWF0dGluZyA9IHByb3BzLmFsbG93RW1wdHlGb3JtYXR0aW5nO1xuICAgIHZhciBmb3JtYXRQcm9wID0gcHJvcHMuZm9ybWF0O1xuICAgIHZhciBpbnB1dE1vZGUgPSBwcm9wcy5pbnB1dE1vZGU7IGlmICggaW5wdXRNb2RlID09PSB2b2lkIDAgKSBpbnB1dE1vZGUgPSAnbnVtZXJpYyc7XG4gICAgdmFyIG9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bjsgaWYgKCBvbktleURvd24gPT09IHZvaWQgMCApIG9uS2V5RG93biA9IG5vb3A7XG4gICAgdmFyIHBhdHRlcm5DaGFyID0gcHJvcHMucGF0dGVybkNoYXI7IGlmICggcGF0dGVybkNoYXIgPT09IHZvaWQgMCApIHBhdHRlcm5DaGFyID0gJyMnO1xuICAgIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgdmFyIHZhbHVlSXNOdW1lcmljU3RyaW5nID0gcHJvcHMudmFsdWVJc051bWVyaWNTdHJpbmc7XG4gICAgdmFyIHJlc3RQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wibWFza1wiLCBcImFsbG93RW1wdHlGb3JtYXR0aW5nXCIsIFwiZm9ybWF0XCIsIFwiaW5wdXRNb2RlXCIsIFwib25LZXlEb3duXCIsIFwicGF0dGVybkNoYXJcIiwgXCJ2YWx1ZVwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcInZhbHVlSXNOdW1lcmljU3RyaW5nXCJdKTtcbiAgICAvLyB2YWxpZGF0ZSBwcm9wc1xuICAgIHZhbGlkYXRlUHJvcHMocHJvcHMpO1xuICAgIHZhciBfZ2V0Q2FyZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIChmb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXRCb3VuZGFyeSQxKGZvcm1hdHRlZFZhbHVlLCBwcm9wcyk7XG4gICAgfTtcbiAgICB2YXIgX29uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBrZXkgPSBlLmtleTtcbiAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGVsLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gZWwuc2VsZWN0aW9uRW5kO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgY2hhcmFjdGVycyBhcmUgc2VsZWN0ZWQgYW5kIHVzZXIgaGl0cyBiYWNrc3BhY2UsIG5vIG5lZWQgdG8gaGFuZGxlIGFueXRoaW5nIG1hbnVhbGx5XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICBvbktleURvd24oZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnJpbmcgdGhlIGN1cnNvciB0byBjbG9zZXN0IG51bWVyaWMgc2VjdGlvblxuICAgICAgICB2YXIgY2FyZXRQb3MgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgLy8gaWYgYmFja3NwYWNlIGlzIHByZXNzZWQgYWZ0ZXIgdGhlIGZvcm1hdCBjaGFyYWN0ZXJzLCBicmluZyBpdCB0byBudW1lcmljIHNlY3Rpb25cbiAgICAgICAgLy8gaWYgZGVsZXRlIGlzIHByZXNzZWQgYmVmb3JlIHRoZSBmb3JtYXQgY2hhcmFjdGVycywgYnJpbmcgaXQgdG8gbnVtZXJpYyBzZWN0aW9uXG4gICAgICAgIGlmIChrZXkgPT09ICdCYWNrc3BhY2UnIHx8IGtleSA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ0JhY2tzcGFjZScpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2FyZXRQb3MgPiAwICYmIGZvcm1hdFByb3BbY2FyZXRQb3MgLSAxXSAhPT0gcGF0dGVybkNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3MtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdExuID0gZm9ybWF0UHJvcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNhcmV0UG9zIDwgZm9ybWF0TG4gJiYgZm9ybWF0UHJvcFtjYXJldFBvc10gIT09IHBhdHRlcm5DaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJldFBvcyA9IGdldENhcmV0UG9zSW5Cb3VuZGFyeSh2YWx1ZSwgY2FyZXRQb3MsIF9nZXRDYXJldEJvdW5kYXJ5KHZhbHVlKSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JtYXRQcm9wW2NhcmV0UG9zXSAhPT0gcGF0dGVybkNoYXIgJiZcbiAgICAgICAgICAgIGtleSAhPT0gJ0Fycm93TGVmdCcgJiZcbiAgICAgICAgICAgIGtleSAhPT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBpZiB1c2VyIGlzIHR5cGluZyBvbiBmb3JtYXQgY2hhcmFjdGVyIHBvc2l0aW9uLCBicmluZyB1c2VyIHRvIG5leHQgYWxsb3dlZCBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgY2FyZXRQb3MgPSBnZXRDYXJldFBvc0luQm91bmRhcnkodmFsdWUsIGNhcmV0UG9zICsgMSwgX2dldENhcmV0Qm91bmRhcnkodmFsdWUpLCAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBjaGFuZ2luZyBjYXJldCBwb3NpdGlvbiwgc2V0IHRoZSBjYXJldCBwb3NpdGlvblxuICAgICAgICBpZiAoY2FyZXRQb3MgIT09IHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKGVsLCBjYXJldFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgb25LZXlEb3duKGUpO1xuICAgIH07XG4gICAgLy8gdHJ5IHRvIGZpZ3VyZSBvdXQgaXNWYWx1ZU51bWVyaWNTdHJpbmcgYmFzZWQgb24gZm9ybWF0IHByb3AgYW5kIHZhbHVlXG4gICAgdmFyIF92YWx1ZSA9IGlzTmlsKHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIHZhciBpc1ZhbHVlTnVtZXJpY1N0cmluZyA9IHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSBudWxsICYmIHZhbHVlSXNOdW1lcmljU3RyaW5nICE9PSB2b2lkIDAgPyB2YWx1ZUlzTnVtZXJpY1N0cmluZyA6IGlzTnVtZXJpY1N0cmluZyQxKF92YWx1ZSwgZm9ybWF0UHJvcCk7XG4gICAgdmFyIF9wcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IHZhbHVlSXNOdW1lcmljU3RyaW5nOiBpc1ZhbHVlTnVtZXJpY1N0cmluZyB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0UHJvcHMpLCB7IHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsIHZhbHVlSXNOdW1lcmljU3RyaW5nOiBpc1ZhbHVlTnVtZXJpY1N0cmluZywgaW5wdXRNb2RlOiBpbnB1dE1vZGUsIGZvcm1hdDogZnVuY3Rpb24gKG51bVN0cikgeyByZXR1cm4gZm9ybWF0JDEobnVtU3RyLCBfcHJvcHMpOyB9LCByZW1vdmVGb3JtYXR0aW5nOiBmdW5jdGlvbiAoaW5wdXRWYWx1ZSwgY2hhbmdlTWV0YSkgeyByZXR1cm4gcmVtb3ZlRm9ybWF0dGluZyQxKGlucHV0VmFsdWUsIGNoYW5nZU1ldGEsIF9wcm9wcyk7IH0sIGdldENhcmV0Qm91bmRhcnk6IF9nZXRDYXJldEJvdW5kYXJ5LCBvbktleURvd246IF9vbktleURvd24gfSk7XG59XG5mdW5jdGlvbiBQYXR0ZXJuRm9ybWF0KHByb3BzKSB7XG4gICAgdmFyIHBhdHRlcm5Gb3JtYXRQcm9wcyA9IHVzZVBhdHRlcm5Gb3JtYXQocHJvcHMpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE51bWJlckZvcm1hdEJhc2UsIE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5Gb3JtYXRQcm9wcykpO1xufVxuXG5leHBvcnQgeyBOdW1iZXJGb3JtYXRCYXNlLCBOdW1lcmljRm9ybWF0LCBQYXR0ZXJuRm9ybWF0LCBnZXRDYXJldEJvdW5kYXJ5IGFzIGdldE51bWVyaWNDYXJldEJvdW5kYXJ5LCBnZXRDYXJldEJvdW5kYXJ5JDEgYXMgZ2V0UGF0dGVybkNhcmV0Qm91bmRhcnksIGZvcm1hdCBhcyBudW1lcmljRm9ybWF0dGVyLCBmb3JtYXQkMSBhcyBwYXR0ZXJuRm9ybWF0dGVyLCByZW1vdmVGb3JtYXR0aW5nIGFzIHJlbW92ZU51bWVyaWNGb3JtYXQsIHJlbW92ZUZvcm1hdHRpbmckMSBhcyByZW1vdmVQYXR0ZXJuRm9ybWF0LCB1c2VOdW1lcmljRm9ybWF0LCB1c2VQYXR0ZXJuRm9ybWF0IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIlNvdXJjZVR5cGUiLCJub29wIiwibWVtb2l6ZU9uY2UiLCJjYiIsImxhc3RBcmdzIiwibGFzdFZhbHVlIiwidW5kZWZpbmVkIiwiYXJncyIsImxlbiIsImFyZ3VtZW50cyIsImV2ZXJ5IiwidmFsdWUiLCJpbmRleCIsImFwcGx5IiwiY2hhcklzTnVtYmVyIiwiY2hhciIsIm1hdGNoIiwiaXNOaWwiLCJ2YWwiLCJpc05hblZhbHVlIiwiaXNOYU4iLCJpc05vdFZhbGlkVmFsdWUiLCJpc0Zpbml0ZSIsImVzY2FwZVJlZ0V4cCIsInN0ciIsInJlcGxhY2UiLCJnZXRUaG91c2FuZHNHcm91cFJlZ2V4IiwidGhvdXNhbmRzR3JvdXBTdHlsZSIsImFwcGx5VGhvdXNhbmRTZXBhcmF0b3IiLCJ0aG91c2FuZFNlcGFyYXRvciIsInRob3VzYW5kc0dyb3VwUmVnZXgiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJ1c2VQZXJzaXN0ZW50Q2FsbGJhY2siLCJjYWxsYmFja1JlZiIsImN1cnJlbnQiLCJwZXJzaXN0ZW50Q2JSZWYiLCJzcGxpdERlY2ltYWwiLCJudW1TdHIiLCJhbGxvd05lZ2F0aXZlIiwiaGFzTmVnYXRpb24iLCJhZGROZWdhdGlvbiIsInBhcnRzIiwic3BsaXQiLCJiZWZvcmVEZWNpbWFsIiwiYWZ0ZXJEZWNpbWFsIiwiZml4TGVhZGluZ1plcm8iLCJpc05lZ2F0aXZlIiwibGltaXRUb1NjYWxlIiwic2NhbGUiLCJmaXhlZERlY2ltYWxTY2FsZSIsImZpbGxlciIsInJlcGVhdCIsImNvdW50IiwiQXJyYXkiLCJqb2luIiwidG9OdW1lcmljU3RyaW5nIiwibnVtIiwiX251bSIsInNpZ24iLCJyZWYiLCJjb2VmZmljaWVudCIsImV4cG9uZW50IiwiTnVtYmVyIiwiZGVjaW1hbEluZGV4IiwiY29mZmllY2llbnRMbiIsIk1hdGgiLCJhYnMiLCJyb3VuZFRvUHJlY2lzaW9uIiwic2hvdWxkSGF2ZURlY2ltYWxTZXBhcmF0b3IiLCJmbG9hdFZhbHVlIiwicGFyc2VGbG9hdCIsImZsb2F0VmFsdWVTdHIiLCJ0b0ZpeGVkIiwicm91bmRlZERlY2ltYWxQYXJ0cyIsImludFBhcnQiLCJyZXZlcnNlIiwicmVkdWNlIiwicm91bmRlZFN0ciIsImlkeCIsInRvU3RyaW5nIiwiZGVjaW1hbFBhcnQiLCJuZWdhdGlvbiIsImRlY2ltYWxTZXBhcmF0b3IiLCJzZXRDYXJldFBvc2l0aW9uIiwiZWwiLCJjYXJldFBvcyIsImNyZWF0ZVRleHRSYW5nZSIsInJhbmdlIiwibW92ZSIsInNlbGVjdCIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZXRTZWxlY3Rpb25SYW5nZSIsImZpbmRDaGFuZ2VSYW5nZSIsInByZXZWYWx1ZSIsIm5ld1ZhbHVlIiwiaiIsInByZXZMZW5ndGgiLCJuZXdMZW5ndGgiLCJmcm9tIiwic3RhcnQiLCJlbmQiLCJ0byIsImNsYW1wIiwibWluIiwibWF4IiwiZ2VJbnB1dENhcmV0UG9zaXRpb24iLCJzZWxlY3Rpb25FbmQiLCJhZGRJbnB1dE1vZGUiLCJuYXZpZ2F0b3IiLCJwbGF0Zm9ybSIsInRlc3QiLCJnZXREZWZhdWx0Q2hhbmdlTWV0YSIsImdldE1hc2tBdEluZGV4IiwibWFzayIsImRlZmF1bHRJc0NoYXJhY3RlclNhbWUiLCJjdXJyZW50VmFsdWUiLCJmb3JtYXR0ZWRWYWx1ZSIsImN1cnJlbnRWYWx1ZUluZGV4IiwiZm9ybWF0dGVkVmFsdWVJbmRleCIsImdldENhcmV0UG9zaXRpb24iLCJuZXdGb3JtYXR0ZWRWYWx1ZSIsImxhc3RGb3JtYXR0ZWRWYWx1ZSIsImN1clZhbHVlIiwiY3VyQ2FyZXRQb3MiLCJib3VuZGFyeSIsImlzVmFsaWRJbnB1dENoYXJhY3RlciIsImlzQ2hhcmFjdGVyU2FtZSIsImZpcnN0QWxsb3dlZFBvc2l0aW9uIiwiZmluZEluZGV4IiwiYiIsInByZWZpeEZvcm1hdCIsInNsaWNlIiwic3RhcnRzV2l0aCIsImN1clZhbExuIiwiZm9ybWF0dGVkVmFsdWVMbiIsImFkZGVkSW5kZXhNYXAiLCJpbmRleE1hcCIsImpMbiIsImlzQ2hhclNhbWUiLCJwb3MiLCJlbmRJbmRleCIsInN0YXJ0SW5kZXgiLCJnZXRDYXJldFBvc0luQm91bmRhcnkiLCJkaXJlY3Rpb24iLCJ2YWxMbiIsImxhc3RJbmRleE9mIiwiY2FyZXRVbmtub3duRm9ybWF0Qm91bmRhcnkiLCJib3VuZGFyeUFyeSIsIm1hcCIsImxuIiwiQm9vbGVhbiIsInVzZUludGVybmFsVmFsdWVzIiwiZGVmYXVsdFZhbHVlIiwidmFsdWVJc051bWVyaWNTdHJpbmciLCJmb3JtYXQiLCJyZW1vdmVGb3JtYXR0aW5nIiwib25WYWx1ZUNoYW5nZSIsImdldFZhbHVlcyIsIm51bUFzU3RyaW5nIiwidmFsdWVzIiwic2V0VmFsdWVzIiwiX29uVmFsdWVDaGFuZ2UiLCJuZXdWYWx1ZXMiLCJzb3VyY2VJbmZvIiwiX3ZhbHVlIiwiX3ZhbHVlSXNOdW1lcmljU3RyaW5nIiwiZGVmYXVsdFJlbW92ZUZvcm1hdHRpbmciLCJkZWZhdWx0Rm9ybWF0IiwiTnVtYmVyRm9ybWF0QmFzZSIsInByb3BzIiwidHlwZSIsImRpc3BsYXlUeXBlIiwiY3VzdG9tSW5wdXQiLCJyZW5kZXJUZXh0IiwiZ2V0SW5wdXRSZWYiLCJpc0FsbG93ZWQiLCJvbkNoYW5nZSIsIm9uS2V5RG93biIsIm9uTW91c2VVcCIsIm9uRm9jdXMiLCJvbkJsdXIiLCJwcm9wVmFsdWUiLCJnZXRDYXJldEJvdW5kYXJ5Iiwib3RoZXJQcm9wcyIsInJlZl8wIiwib25Gb3JtYXR0ZWRWYWx1ZUNoYW5nZSIsImxhc3RVcGRhdGVkVmFsdWUiLCJzb3VyY2UiLCJyZWYkMSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwiZm9jdXNlZEVsbSIsInRpbWVvdXQiLCJzZXRDYXJldFRpbWVvdXQiLCJmb2N1c1RpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJfZm9ybWF0IiwiZ2V0VmFsdWVPYmplY3QiLCJzZXRQYXRjaGVkQ2FyZXRQb3NpdGlvbiIsInNldFRpbWVvdXQiLCJjb3JyZWN0Q2FyZXRQb3NpdGlvbiIsImdldE5ld0NhcmV0UG9zaXRpb24iLCJpbnB1dFZhbHVlIiwiY2FyZXRCb3VuZGFyeSIsInVwZGF0ZWRDYXJldFBvcyIsInVwZGF0ZVZhbHVlQW5kQ2FyZXRQb3NpdGlvbiIsInBhcmFtcyIsImlucHV0IiwiZXZlbnQiLCJjdXJyZW50Q2FyZXRQb3NpdGlvbiIsImxhc3ROdW1Bc1N0cmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJmb3JtYXRJbnB1dFZhbHVlIiwiY2hhbmdlUmFuZ2UiLCJjaGFuZ2VNZXRhIiwiYXNzaWduIiwiX251bUFzU3RyaW5nIiwiX2Zvcm1hdHRlZFZhbHVlIiwidGFyZ2V0IiwiX29uQ2hhbmdlIiwiY2hhbmdlZCIsIl9vbktleURvd24iLCJrZXkiLCJleHBlY3RlZENhcmV0UG9zaXRpb24iLCJuZXdDYXJldFBvc2l0aW9uIiwicHJldmVudERlZmF1bHQiLCJpc1VuaXRUZXN0UnVuIiwiX29uTW91c2VVcCIsImNhcmV0UG9zaXRpb24iLCJfb25Gb2N1cyIsInBlcnNpc3QiLCJjdXJyZW50VGFyZ2V0IiwiX29uQmx1ciIsImlucHV0TW9kZSIsImlucHV0UHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJDdXN0b21JbnB1dCIsImRlY2ltYWxTY2FsZSIsInByZWZpeCIsInN1ZmZpeCIsImdldFNlcGFyYXRvcnMiLCJoYXNEZWNpbWFsU2VwYXJhdG9yIiwiYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzIiwiaGFuZGxlTmVnYXRpb24iLCJuZWdhdGlvblJlZ2V4IiwiUmVnRXhwIiwiZG91YmxlTmVnYXRpb25SZWdleCIsInJlbW92ZU5lZ2F0aW9uIiwiZ2V0TnVtYmVyUmVnZXgiLCJnbG9iYWwiLCJpc051bWVyaWNTdHJpbmciLCJpc0JlZm9yZURlY2ltYWxTZXBhcmF0b3IiLCJzZXBhcmF0b3IiLCJzdHJpcE5lZ2F0aW9uIiwiaGFzRG91YmxlTmVnYXRpb24iLCJjaGFyc1RvUmVtb3ZlIiwidG9NZXRhZGF0YSIsImZyb21TdGFydCIsImZyb21FbmQiLCJ1cGRhdGVkU3VmZml4UGFydCIsInN1ZmZpeFN0YXJ0SW5kZXgiLCJlbmRzV2l0aCIsImZpcnN0SW5kZXgiLCJyZWYkMiIsImZpbGwiLCJ2YWxpZGF0ZUFuZFVwZGF0ZVByb3BzIiwiRXJyb3IiLCJjb25zb2xlIiwiZXJyb3IiLCJ1c2VOdW1lcmljRm9ybWF0IiwiX2RlY2ltYWxTZXBhcmF0b3IiLCJfYWxsb3dlZERlY2ltYWxTZXBhcmF0b3JzIiwiYWxsb3dMZWFkaW5nWmVyb3MiLCJyZXN0UHJvcHMiLCJfcmVtb3ZlRm9ybWF0dGluZyIsInJvdW5kSW5jb21pbmdWYWx1ZVRvUHJlY2lzaW9uIiwicmVmJDFfMCIsImluY2x1ZGVzIiwiX3Rob3VzYW5kU2VwYXJhdG9yIiwiaW5wdXRDaGFyIiwiY3VyQ2hhciIsIm5ld0NoYXIiLCJ0eXBlZFJhbmdlIiwiTnVtZXJpY0Zvcm1hdCIsIm51bWVyaWNGb3JtYXRQcm9wcyIsImZvcm1hdCQxIiwiYWxsb3dFbXB0eUZvcm1hdHRpbmciLCJwYXR0ZXJuQ2hhciIsImhhc2hDb3VudCIsImZvcm1hdHRlZE51bWJlckFyeSIsInJlbW92ZUZvcm1hdHRpbmckMSIsImlzTnVtZXJpY1Nsb3QiLCJyZW1vdmVGb3JtYXRDaGFyIiwic3RyaW5nIiwiZXh0cmFjdE51bWJlcnMiLCJmaXJzdFNlY3Rpb24iLCJtaWRkbGVTZWN0aW9uIiwibGFzdFNlY3Rpb24iLCJnZXRDYXJldEJvdW5kYXJ5JDEiLCJmaXJzdEVtcHR5U2xvdCIsIm1hc2tBbmRJbmRleE1hcCIsImZvckVhY2giLCJtYXNrQXRJbmRleCIsImlzUG9zQWxsb3dlZCIsInZhbGlkYXRlUHJvcHMiLCJtYXNrQXNTdHIiLCJpc051bWVyaWNTdHJpbmckMSIsInVzZVBhdHRlcm5Gb3JtYXQiLCJmb3JtYXRQcm9wIiwiX2dldENhcmV0Qm91bmRhcnkiLCJmb3JtYXRMbiIsImlzVmFsdWVOdW1lcmljU3RyaW5nIiwiX3Byb3BzIiwiUGF0dGVybkZvcm1hdCIsInBhdHRlcm5Gb3JtYXRQcm9wcyIsImdldE51bWVyaWNDYXJldEJvdW5kYXJ5IiwiZ2V0UGF0dGVybkNhcmV0Qm91bmRhcnkiLCJudW1lcmljRm9ybWF0dGVyIiwicGF0dGVybkZvcm1hdHRlciIsInJlbW92ZU51bWVyaWNGb3JtYXQiLCJyZW1vdmVQYXR0ZXJuRm9ybWF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js\n");

/***/ })

};
;